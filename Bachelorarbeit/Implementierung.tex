
\chapter{Implementierung}
Grobe Funktionsweisen der Implementierung wurden bereits im Kapitel Systemarchitektur erläutert. In diesem Kapitel wird auf detaillierte Implementierungsaspekte anspruchsvoller Prozesse mit Hilfe von Codeausschnitten eingegangen. Funktionen, die weniger komplex sind und deren Behandlung im Kapitel Systemarchitektur als ausreichend angesehen wird, werden nicht erneut thematisiert.
    \section{Frontend-Entwicklung}
    \subsection{Authentifizierung}
    \label{sec:Auth-Impl-Front}
Die verschiedenen Art und Weisen und Abläufe der Authentifizierung wurde im Kapitel \ref{sec:Autehtifizierung Frontend} behandelt.
In diesem Kapitel werde ich näher auf die genaue Implementierung dieser Abläufe eingehen, erklären wie die Formik Formulare funktionieren und konkrete Codeausschnitte vorstellen.
    \subsubsection{Erster Versuch der Authetifizierung mittels Cookie}
    \label{sec:Cookie-auth}
Im Codeausschnitt \ref{lst:AccountContext} ist der Code der gesamten AccountContext Datei zu sehen, welche den \verb|user|-State zur Verfügung stellt.

\begin{lstlisting}[style=codeStyle, caption={Die AccountContext.js-Datei}, label={lst:AccountContext}]
import React, {useEffect, useState, createContext} from "react";

export const AccountContext = createContext();

const UserContext = ({children}) => {
    const [user, setUser] = useState({loggedIn: null});

    useEffect(() => {
        fetch(`${process.env.REACT_APP_API_URL}/auth/login`, {
            credentials: "include",
        })
            .catch(err => {
                console.log(err);
                return;
            })
            .then(r => {
                if (!r || !r.ok || r.status >= 400) {
                    return;
                }
                return r.json();
            })
            .then(data => {
                setUser({ ...data});
            });
    }, []);
    return (
        <AccountContext.Provider value ={{user, setUser}}>
            {children}
        </AccountContext.Provider>
    );
}
export default UserContext;
\end{lstlisting}


In ihr wird der State \verb|user| mit \verb|{loggedIn: null}| initialisiert. Weshalb wir dies tun wird durch den Codeausschnitt \ref{lst:Views-user-socket} und dessen Erklärung in Abschnitt \ref{sec:socket-Verbindung} ersichtlich. Sobald die Komponente gerendert wurde, wird die Funktion der \verb|useEffect|-Hook ausgeführt. Das leere Dependency Array verursacht, dass sie nur beim Starten der Anwendung ausgeführt wird. Die Funktion schickt eine HTTP GET-Anfrage unter \verb|/auth/login| an den Server mit der Option, dass Credentials mitgesendet werden sollen. Dies stellt sicher, dass der Cookie mit dem JWT-Token an den Server gesendet wird und dort verifiziert werden kann\footnote{Quelle: \url{https://javascript.info/fetch-crossorigin\#credentials} am 11. Mai 2023}. Der restliche Pfad ist als Umgebungsvariable gesetzt um den Pfad flexibel ändern zu können.

Gibt es einen Fehler oder eine ungültige Antwort wird der Vorgang abgebrochen, ansonsten wird der \verb|user| mit den erhaltenen Daten gesetzt.

Mögliche Optionen sind dabei:
\begin{itemize}
\item \verb|{loggedIn: false}|, falls nicht authentifiziert werden konnte.
\item \verb|{loggedIn: true, username: Max}|, bei erfolgreichem Authentifizieren. (Max ist hier nur ein Beispiel als \verb|username|)
\end{itemize}

Auch wenn im JWT-Token mehr Daten kodiert sind, benötigt das Frontend aktuell nicht mehr Informationen.
\subsubsection{Authentifizierung mittels \textit{SignUp}- oder \textit{Login}-Komponente}
Um sich mit Hilfe von den \textit{SignUp}- oder \textit{Login}-Komponenten anzumelden wird eine HTTP POST-Anfrage an den Server unter dem Pfad \verb|/auth/login| oder \verb|/auth/signup| gesendet.

Die Funktion zum Senden der Login-Daten an den Server befindet sich in Codeausschnitt \ref{lst:submitLogin}.

\begin{lstlisting}[style=codeStyle, caption={Die Funktion zum Senden der Benutzerdaten an das Backend}, label={lst:submitLogin}]
    const submitLogin = useCallback((values, setSubmitting) => {
        fetch(`${process.env.REACT_APP_API_URL}/auth/login`, {
            method: "POST",
            credentials: "include",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(values)
        })
            .catch(err => {
                setLoginError("Please try again later");
                setSubmitting(false);
                return;
            })
            .then(res => {
                if (!res || !res.ok || res.status >= 400) {
                    setSubmitting(false);
                    setLoginError("Please try again later");
                    return;
                }
                return res.json();
            })
            .then(data => {
                if (!data.loggedIn) {
                    setLoginError(data.message);
                    setSubmitting(false);
                    return;
                }
                setUser({...data});
                setLoginError(null);
                navigate('/');
            });
    }, [setLoginError, setUser, navigate]);
\end{lstlisting}

Die Funktion zum Senden der Registrierungs-Daten ist ähnlich aufgebaut, nur dass die Anfrage an einen anderen Pfad geht und es mehr Daten enthält, wie zum Beispiel die E-Mail Adresse.

Initialisiert wird die Funktion mittels der \textit{useCallback}-Hook um unnötige Neuerstellungen zu vermeiden (siehe Kapitel \ref{sec:react}). Der \glqq Content-Type\grqq{ }hilft dem Server zu erkennen um was für eine Art von Daten es sich handelt\footnote{Quelle: \url{https://javascript.info/fetch\#post-requests} am 11. Mai 2023}, während im Body die angegebenen Anmeldedaten als JSON-String verpackt werden. Falls der Server mit einem Fehler Antwortet, wird dieser durch den State \verb|loginError| erfasst und dargestellt. Ansonsten wird der Benutzerstatus gesetzt und es wird auf den Pfad \glqq /\grqq{ } navigiert, auf der sich die \textit{Home}-Komponente befindet.

Das Formular wird mittels Formik reaktiv und nutzt Yup Schemata zum Überprüfen der eingegebenen Werte.

\begin{lstlisting}[style=codeStyle, caption={Ein Ausschnitt der \textit{Login}-Komponente mit Formik}, label={lst:Login_Formik}]
...
<Formik
    initialValues={{
        username: "",
        password: "",
    }}
    validationSchema={LoginSchema}
    validateOnChange={true}
    onSubmit={(values, { setSubmitting }) => {
        submitLogin(values, setSubmitting);
    }}
>
    {({ isValid, isSubmitting }) => (
        <Form style={{ width: "100%" }}>
        		...
            <Field name="password">
               {({ field, form }) => (
                  <FormControl isInvalid={form.errors.password && form.touched.password}>
                      <FormLabel htmlFor="password">Password</FormLabel>
                      <InputGroup>
                           <Input {...field} 
                           	id="password" 
                           	type={showPassword ? 'text' : 'password'} 
                           	autoComplete="current-password" />
                           <InputRightElement>
                               <IconButton
                                   icon={showPassword ? <ViewOffIcon /> : <ViewIcon />}
                                   onClick={handlePasswordClick}
                                   variant="ghost"
                                   _hover={{ bg: hover }}
                                   aria-label="Toggle password visibility"
                               />
                           </InputRightElement>
                       </InputGroup>
                       <FormErrorMessage>{form.errors.password}
                       </FormErrorMessage>
                   </FormControl>
               )}
            </Field>
            ...
            <Button
                type="submit"
                isDisabled={!isValid || isSubmitting}
                ...
            >
               Log In
            </Button>
            ...
\end{lstlisting}

In diesem Codeausschnitt ist das von Formik verwaltete Formular der \textit{Login}-Komponente zu erkennen (die Komponente ist in Abbildung \ref{fig:Login} dargestellt). Als Schema für dieses Formular wird das Yup Schema \verb|LoginSchema| verwendet (siehe Codeausschnitt \ref{lst:Yup-Login}) und es wird definiert, dass bei jeder neuen Änderung der Eingabefelder des Formulars, die Eingaben auf das Schema getestet werden sollen (siehe Zeilen 7 \& 8 des Codeausschnitts \ref{lst:Login_Formik}).

\verb|isValid| und \verb|isSubmitting| (siehe Zeile 13 des Codeausschnitts \ref{lst:Login_Formik}) sind props, die man von Formik zur Verfügung gestellt bekommt und die angeben, ob die Eingabefelder mit dem Schema übereinstimmen und ob gerade auf die Antwort des Servers gewartet wird. Dies ist auch der Grund, warum wir \verb|setSubmitting| der \verb|submitLogin| Funktion übergeben (siehe Zeile 9 des Codeausschnitts \ref{lst:Login_Formik}). Wird auf die Antwort des Servers gewartet oder das Formular stimmt nicht mit dem Schema überein, wird der Button deaktiviert, sodass man ihn nicht mehr klicken und das Formular nicht absenden kann (siehe Zeile 42 \& 43 des Codeausschnitts \ref{lst:Login_Formik}).

Als Eingabefelder, gibt es  den Benutzernamen und das Passwort. Aus Demonstrationszwecken habe ich in den Codeausschnitt \ref{lst:Login_Formik} nur das Passwort eingefügt.

Die Props \verb|field| und \verb|form| (siehe Zeile 17 des Codeausschnitts \ref{lst:Login_Formik}) versorgen das Feld mit Informationen und Funktionen für das Feld und über das gesamte Formular. So wird in Zeile 21 das Input Feld mit dem \verb|field| prop verknüpft, welches Attribute und Funktionen wie \verb|field.onChange| oder \verb|field.value| besitzt. \verb|form| wird genutzt, um, beispielsweise wie in Zeile 35, ein Fehler beim Passwort anzuzeigen, falls dies nicht mit dem Schema übereinstimmt\footnote{Quelle: \url{https://formik.org/docs/api/field} am 11. Mai 2023}.

Gestaltet wird das Formular mit Komponenten von Chakra UI, welche viele hilfreiche Komponenten wie \verb|FormErrorMessage| oder \verb|IconButton| bereitstellt. Mit Attributen wie \verb|_hover| oder \verb|variant| können diese Komponenten noch weiter individualisiert werden (siehe Kapitel \ref{sec:Design}).

Die \textit{Login}-Komponente besitzt den boolean State \verb|showPassword|, welcher angibt, ob das Passwort zu sehen sein soll oder nicht (siehe Zeile 23 des Code Ausschnitts \ref{lst:Login_Formik}). Bei einem Klick auf das Icon mit dem Auge wird die Funktion \verb|handlePasswordClick| ausgeführt, welche den \verb|showPassword| State negiert. Je nach dem aktuellen Wert des States \verb|showPassword| wird ein Auge oder ein durchgestrichenes Auge als Icon angezeigt.

Die Formulierung von Schemata mittels Yup ist relativ simpel.

\begin{lstlisting}[style=codeStyle, caption={Yup Schma für das Anmelden}, label={lst:Yup-Login}]
const LoginSchema = Yup.object().shape({
    username: Yup.string()
        .min(3, 'Username has to be at least 3 characters long')
        .max(20, 'Username cannot be longer than 20 characters')
        .test('not_guest', 'Username cannot start with "guest"', (value) => {
            return !value.startsWith('guest');
        })
        .test('no colon', 'Username cannot include ":"', (value) => {
            return !value.includes(':');
        })
        .required('Username is a required field'),
    password: Yup.string()
        .min(8, 'Password has to be at least 8 characters long')
        .minLowercase(1, 'At least one character hat to be in lower case')
        .minUppercase(1, 'At least one character has to be in upper case')
        .minNumbers(1, 'At least on character has to be a number')
        .minSymbols(1, 'At least one character has to be a symbol')
        .minRepeating(3, 'It is only allowed to have at most 3 repeating characters')
        .required('Password is a required field'),
});
\end{lstlisting}

In diesem Beispiel ist das \verb|LoginSchema| zu sehen, welches für die Validierung der Eingabefelder im Anmeldeformular aus Codeausschnitt \ref{lst:Login_Formik} verwendet wird. Yup ermöglicht es bestimmte Restriktionen an Eingabefelder zu stellen und dabei direkt die Fehlernachrichten zu definieren, falls eine Restriktion nicht erfüllt ist. Selbstverständlich sind die Restriktionen für das Registrieren die gleichen, wobei das Registrierungsformular noch ein paar weitere Felder hat.

Verwendet werden übliche Restriktionen an Benutzernamen und Passwörter, sodass das Passwort mindestens eine Nummer, ein Symbol, einen Großbuchstaben, ... beinhalten muss. Eine Sonderheit ist, dass der Benutzername nicht mit \glqq guest\grqq{ }beginnen darf (siehe Zeile 5 f. des Codeausschnitts \ref{lst:Yup-Login}), da unangemeldete Benutzer bei Schachpartien einen solchen Benutzernamen zugewiesen bekommen (siehe Kapitel \ref{sec:Schach-Backend-impl}). Eine zweite Sonderheit ist, dass der Benutzername keinen Doppelpunkt beinhalten darf. Dies liegt daran, dass wir in der Redis Datenbank öfters die \verb|userid| mit dem Benutzernamen mit einem Doppelpunkt in einem String verbinden (siehe Kapitel \ref{sec:friends:username}).


\subsubsection{Socket.io Verbindungsaufbau}
\label{sec:socket-Verbindung}
Immer sobald sich der Benutzerzustand ändert wird eine Socket.io Verbindung hergestellt und den anderen Komponenten zur Verfügung gestellt. Dies hat den Nutzen, dass beim Verbindungsaufbau immer auch die Socket auf dem Server authentifiziert werden muss.

Dafür wird die \textit{SocketContext}-Komponente verwendet:

\begin{lstlisting}[style=codeStyle, caption={Die Datei \textit{SocketContext.js}}, label={lst:SocketContext}]
import {io} from "socket.io-client";
import React, {useContext, useEffect, useState, createContext} from "react";
import {AccountContext} from "./AccountContext.js";

export const SocketContext = createContext();

function SocketConnectionContext({children}) {
    const [socket, setSocket] = useState(null);
    const {user} = useContext(AccountContext);

    useEffect(() => {
        if(user.loggedIn !== null) {
            if(socket) {
                socket.disconnect();
            }
            setSocket(new io(process.env.REACT_APP_SOCKET_URL, {
                withCredentials: true
            }));
        }
    }, [user]);

    return (
        <SocketContext.Provider value={{socket}}>
            {children}
        </SocketContext.Provider>
    );
}

export default SocketConnectionContext;
\end{lstlisting}

Bei der Verbindung wird darauf geachtet, dass die Credentials mitgesendet werden, also beispielsweise auch Cookies. Des weiteren wird erst eine Verbindung aufgebaut, sobald die Antwort des Servers auf die Authentifizierungs-Anfrage mittels Cookie (siehe Abschnitt \ref{sec:Cookie-auth}) empfangen wurde und dadurch das \verb|user.loggedIn| Attribut nicht mehr \verb|null| ist. Dies dient dazu einen unnötigen Verbindungsaufbau zu unterlassen, da nach der Antwort des Servers in der \textit{UserContext}-Komponente ohnehin eine neue Verbindung aufgebaut werden würde.
Die Verbindung der Socket zu trennen vor der neuen Verbindung hat den Sinn, im Backend ein \verb|diconnect| Event zu triggern (siehe Kapitel \ref{sec:Backend-Socket}).

Erst sobald die erste Authentifizierung stattgefunden hat und eine Socket.io Verbindung hergestellt wurde, werden die verschiedenen Elemente und Routen in der \verb|Views|-Komponente definiert. So lange wird ein Lade-Bildschirm gezeigt (siehe Codeausschnitt \ref{lst:Views-user-socket}).

\begin{lstlisting}[style=codeStyle, caption={Ausschnitt der \textit{Views}-Komponente}, label={lst:Views-user-socket}]
		   ...
        {user.loggedIn === null || socket === null ?
                <Flex align="center" justify="center" direction="column" height="80vh">
                    <Heading as='h2' size='lg'>Loading...</Heading>
                    <Spinner size='xl' color="purple.500" marginTop="4"/>
                </Flex>

                :
                <>
                    <Navbar/>
                    ...
\end{lstlisting}

\subsection{Das Schachspiel}
In diesem Abschnitt werde ich darauf eingehen, was passiert nachdem die Daten erfolgreich vom Backend empfangen wurden, wie ein neuer Zug gehandhabt wird und wie die Bauernumwandlung implementiert ist.
Der Ablauf wie eine gegnerische Pperson gefunden wird, wie auf die \textit{ChessGame}-Komponente navigiert wird und welche Daten von dem Backend empfangen werden befindet sich in Kapitel \ref{sec:Schachspiel}.

\subsubsection{Initialisierung nach dem Empfangen der Daten}

\begin{lstlisting}[style=codeStyle, caption={Initialisierung des Schachspiels nach Empfangen der Daten}, label={lst:chessground}]
useEffect(() => {
    if(initialized) {
            setGround(new Chessground(document.getElementById(roomId), {
                fen: chess.fen(),
                orientation: orientation,
                viewOnly: isSpectator,
                movable: {
                    free: false,
                    color: orientation,
                    showdests: true
                },
                premovable: {
                    enabled: false
                },
                animation: {
                    enabled: true,
                    duration: 400
                }
            }));
    }
}, [initialized]);
    
useEffect(() => {
    if(ground) {
        ground.set({
            movable: {
                events: {
                    after: onMove(ground, chess)
                }
            }
        });
        refreshBoard(ground, chess);        
        socket.on('opponent_move', (move) => {
            if(move.flags.includes('p')) {
                onOpponentPromotion(move);
                return;
            }
            ground.move(move.from, move.to);
            chess.move(move);
            if(move.flags.includes('e')) {
                onEnPassent(ground, move);
            }
            refreshBoard(ground, chess);
        });
        socket.on('cancel_game', () => {...});
        socket.on('time_over', (color) => {...});
        socket.on('checkmate', (winner) => {...});
        socket.on('draw', () => {...});
        socket.on('resigned', (color) => {...});
    }
    return () => {
        socket.off('opponent_move');
        socket.off('Checkmate');
        socket.off('draw');
        socket.off('time_over');
        socket.off('cancel_game');
        socket.off('resigned');
    }
}, [socket, ground, initialized, ground, chess, orientation, whitePlayer, blackPlayer]);
\end{lstlisting}

Sobald erfolgreich die Daten mit dem \verb|get_game_data| Event empfangen und gesetzt wurden, wird \verb|initialized| auf true gesetzt, um die nächsten Schritte in Gang zu leiten.

Zunächst wird ein chessground Objekt mit Konfigurationen erstellt. In diesem wird übermittelt, wie die Figuren gerade stehen (mittels FEN-Notation) (siehe Zeile 4), die Orientierung welche Farbe nach unten zeigen soll (siehe Zeile 5), ob man Figuren bewegen darf und wenn ja welche (Zeile 6-11) und weitere Optionen. Dieses chessground Interface wird dann in dem definierten div-Bock angezeigt (siehe Zeile 3 des Codeausschnitts \ref{lst:chessground}).

Wurde chessground initialisiert, wird noch die Methode \verb|onMove| zu chessground hinzugefügt, die ausgeführt werden soll, wenn man selbst einen Zug macht (siehe Zeile 28 Codeausschnitt \ref{lst:chessground}) und Listener für verschiedene Events des Schachspiels werden initialisiert. Diese Listener werden wieder entfernt (siehe Zeile 52 ff. in Codeausschnitt \ref{lst:chessground}), falls die \textit{ChessGame}-Komponente verlassen wird, da sie nur für dieses Spiel auf die Events hören sollen und bei einem neuen Spiel neue Listener initialisiert werden.

Nach jedem Zug, egal ob eigener oder einer gegnerischen Person, wird die \verb|refreshBoard| Methode aufgerufen.

\begin{lstlisting}[style=codeStyle, caption={Die refreshBoard Methode}, label={lst:refreshBoard}]
export function refreshBoard(ground, chess) {
    ground.set({
        turnColor: toColor(chess),
        movable: {
            dests: getValidMoves(chess)
        }
    });
}
\end{lstlisting}

Diese Methode sorgt dafür, dass eine Figur von chessground nur auf legale Züge ziehen darf und korrekt aktualisiert wird, welche/-r Spieler/-in an der Reihe ist.

Ein \verb|move| Objekt, das zurückgegeben wird nach dem Ziehen eines Zuges auf einem chess.js Objekt (siehe \verb|move| Parameter Zeile 39 in Codeausschnitt \ref{lst:chessground} oder Zeile 10 Codeausschnitt \ref{lst:onMove})) ist folgendermaßen aufgebaut\footnote{Quelle: \url{https://github.com/jhlywa/chess.js/} am 08. Mai 2023}:
\begin{verbatim}
{ color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' }
\end{verbatim}
Vor allem relevant sind die flags dieses Objekts, da sie ausdrücken um was für eine Art von Zug es sich handelt. Wird als flag beispielsweise \glqq e\grqq{ }angegeben, handelt es sich um ein en passant. Bei einem \glqq p\grqq{ }liegt eine Bauernumwandlung vor.
Je nachdem ob eines dieser flags vorhanden ist, wird der Zug anders verarbeitet (siehe Zeilen 34 \& 40 des Codeausschnitts \ref{lst:chessground}). Wie ein gegnerischer Zug behandelt wird (siehe Zeile 33 ff. in Codeausschnitt \ref{lst:chessground}), ist in Kapitel \ref{sec:Das-Schachspiel-Front} erläutert.

\subsubsection{Neuer Zug}

\begin{lstlisting}[style=codeStyle, caption={Die onMove Methode}, label={lst:onMove}]
const onMove = useCallback(() => {
    return (orig, dest) => {
    		//Promotion
        if((dest.includes('8') || dest.includes('1')) && chess.get(orig).type === 'p') { 
            setSelectVisible(true);
            setPromotionMove([orig, dest]);
            return;
        }
        const player = (orientation === 'white') ? whitePlayer : blackPlayer;
        const move = chess.move({from: orig, to: dest});
        socket.emit('new_move',roomId, player, move, ({done, errMsg}) => {
            if(!done) {
                chess.undo();
                ground.set({fen: chess.fen()});
                toast({
                    title: "Invalid Move",
                    description: errMsg,
                    status: "error",
                    position: "top",
                    isClosable: true
                });
                refreshBoard(ground, chess);
                return;
            }
        });
        if(move.flags.includes('e')) {
            onEnPassent(ground, move);
        }
        refreshBoard(ground, chess);
    };
}, [socket, chess, roomId, ground, orientation, setSelectVisible, setPromotionMove, whitePlayer, blackPlayer]);
\end{lstlisting}

Die \verb|onMove| Methode, welche ausgeführt wird, sobald auf dem chessground Interface eine Figur von der spielenden Person bewegt wurde, behandelt, wie schon in Abschnitt \ref{sec:Das-Schachspiel-Front} erläutert, en passant- und Bauernumwandlungszüge gesondert. Wenn es sich um eine Bauernumwandlung handelt (ein Zug in Reihe 1 oder 8 mit einem Bauern), wird \verb|selectVisible| auf true gesetzt, welches bewirkt, dass die Komponente \textit{PromotionModal} sein Modal öffnet und man eine Figur auswählen kann, in welche der Bauer transformiert werden soll. Um die Felder dieses Zuges zu speichern und außerhalb dieser Methode Verfügbar zu machen, werden sie in den State \verb|promotionMove| gespeichert (siehe Zeile 6 des Codeausschnitts \ref{lst:onMove}).

\begin{lstlisting}[style=codeStyle, caption={Die promotion Methode}, label={lst:promotion}]
const promotion = useCallback(
    (toPiece) => {
        const move = chess.move({from: promotionMove[0], to: promotionMove[1], promotion: toPiece});
        ground.state.pieces.set(promotionMove[1], {
            role: charPieceToString(toPiece),
            color: parseInt(promotionMove[1].split('')[1]) === 8 ? 'white' : 'black',
            promoted: true
        });
        const player = (orientation === 'white') ? whitePlayer : blackPlayer;
        socket.emit('new_move', roomId, player,  move, ({done, errMsg}) => {
            if(!done) {
                chess.undo();
                ground.set({fen: chess.fen()});
                toast({
                    title: "Invalid Move",
                    description: errMsg,
                    status: "error",
                    position: "top",
                    isClosable: true
                });
                refreshBoard(ground, chess);
                return;
            }
        });
        setPromotionMove([]);
        setSelectVisible(false);
        refreshBoard(ground, chess);
    },
    [socket, roomId, chess, ground, promotionMove]
);
\end{lstlisting}

Wurde auf eine Figur des Modals geklickt, wird von dort die Methode \verb|promotion| mit der entsprechenden Figur ausgeführt. Dann wird sowohl auf der chess.js, als auch auf der chessGround Instanz diese Bauernumwandlung durchgeführt, an das Backend gesendet und die States \verb|promotionMove| und \verb|selectVisible| werden zurückgesetzt. Da chess.js und chessground verschiedene Notationen der Figuren verwenden transformiert die Funktion \verb|charPieceToString| die Notation der Figuren beispielsweise von \glqq q\grqq{ } in \glqq queen\grqq . Die Farbe der Figur wird durch die Reihe ermittelt in der die Bauernumwandlung stattfindet (siehe Zeile 6 des Codeausschnitts \ref{lst:promotion}).

\subsubsection{Schachuhr}
\label{sec:impl-schachuhr}
Die Komponente \textit{ChessClock} übernimmt die Verwaltung und die Darstellung der Schachuhren. Die Listener dieser Komponente wurden in Kapitel \ref{sec:Frontend-Uhr} erläutert.

\begin{lstlisting}[style=codeStyle, caption={Ausschnitt der \textit{ChessClock}-Komponente}, label={lst:ChessClock}]
...
const currentTimer = useRef(0);
...
socket.on('updated_time', (timeWhite, timeBlack, turn) => {
            stopClocks();
            updateTime(timeWhite, timeBlack);
            setCurrentTurn(turn);
        });
...
useEffect(() => {
    if(currentTurn === 'off') {
        return;
    }
    const functionMap = {
        tw: setTimeWhite,
        tb: setTimeBlack,
        sw: setStartingTimeWhite,
        sb: setStartingTimeBlack,
    };
    const setFunction = functionMap[currentTurn];
    const id = setInterval(() => {
        decrease(setFunction);
    }, 1000);
    currentTimer.current = id;
    return () => {
        clearInterval(id);
    }
}, [currentTurn]);
\end{lstlisting}

Mit diesem Beispiel kann man gut demonstrieren, wie vielfältig die \verb|useEffect|-Hook genutzt werden kann. Man nutzt in diesem Fall keine selbst definierte Funktion um eine Zeit zu starten, sondern nutzt die Eigenschaft der Hook, dass sie ausgeführt wird sobald sich ein Wert des Dependecy Arrays (in diesem Fall \verb|currentTurn|) ändert, um eine Zeit starten zu lassen. Den State der Zeit die ablaufen soll wird mittels \verb|currentTurn| definiert. Diese kann die folgenden Werte annehmen:

\begin{itemize}
\item \glqq sw\grqq : Die Startzeit von Weiß läuft.
\item \glqq sb\grqq : Die Startzeit von Schwarz läuft
\item \glqq tw\grqq : Die reguläre Zeit von Weiß läuft.
\item \glqq tb\grqq : Die reguläre Zeit von Schwarz läuft.
\item \glqq off\grqq : Keine Zeit läuft.
\end{itemize}

Diese Werte werden auch in der serverseitigen Schachuhr verwendet (siehe Kapitel \ref{sec:Uhr-Backend-impl}).

Die \verb|setInterval|-Methode (siehe Zeile 21 ff. des Codeausschnitte \ref{lst:ChessClock}) akzeptiert als ersten Parameter eine Funktion und als zweiten Parameter eine Zahl, die das Zeitintervall in Millisekunden angibt, in dem die Funktion ausgeführt werden soll. In unserem Fall soll die verbleibende Zeit jede Sekunde um eine Sekunde reduziert werden. Die \verb|setInterval|-Methode gibt eine ID zurück, die in der \verb|useRef|-Variable \verb|currentTimer| gespeichert wird. Im Vergleich zur \verb|useState|-Hook hat die \verb|useRef|-Hook den Vorteil, dass sie keine Neurenderung der Komponente auslöst, wenn sich der Wert ändert, und besser geeignet ist, um Werte über mehrere Rendervorgänge hinweg persistent zu speichern\footnote{Quelle: \url{https://react.dev/reference/react/useRef} am 09. Mai 2023}.

Über \verb|currentTimer| kann in anderen Funktionen, beispielsweise beim Anhalten einer Uhr, auf die ID zugegriffen werden, und die \verb|setInterval|-Funktion kann mit \\ \verb|clearInterval(currentTimer.current)| gestoppt werden.

\subsection{Verwaltung von Freunden}
Die Verwalutung von Freunden und Freundschaftsanfragen im Frontend wurde in Kapitel \ref{sec:Friends} behandelt. In diesem Kapitel möchte ich konkrete Code Beispiele der Komponenten erläutern.

\subsubsection{Darstellung der Freundesliste}
\begin{lstlisting}[style=codeStyle, caption={Darstellung der Freundesliste in \textit{FriendList}}, label={lst:FriendList}]
{friends.length === 0 ? (
    <Text>No Friends</Text>
  ) : (
    <>
      {friends
        .slice()
        .sort((a, b) => (a.connected === "true") - (b.connected === "true"))
        .map((friend) => (
          <Friend key={friend.username} friend={friend} times={props.times} />
        ))}
    </>
  )
}
\end{lstlisting}

Die Darstellung von Daten in Arrays kann in React mittels der Array \verb|map()| Funktion unkompliziert gehandhabt werden. Doch vor der Darstellung wird die Freundesliste noch nach dem \verb|connected| Status sortiert, sodass Freunde die online sind zuerst angezeigt werden.

Dafür wird die Methode \verb|sort()| verwendet. Diese nimmt eine Funktion mit zwei Parametern (hier \verb|a| und \verb|b|) entgegen, die jeweils ein Element des Arrays sind. Gibt uns die Funktion eine positive Zahl zurück, muss Element \verb|a| vor Element \verb|b| sortiert sein. Bei negativen anders herum und bei 0 ist es gleichgültig. Indem die Booleschen Werte von einander subtrahiert werden, werden ihnen Zahlen zugeordnet: 1 für \verb|true| und 0 für \verb|false|. Nun haben wir die folgenden Szenarien: Wenn beide den gleichen Status haben ist der Wert 0. Ist \verb|a.connected| true und \verb|b.connected| ist false: 1-0=1 $\Rightarrow$ \verb|a| wird vor \verb|b| sortiert. Anders herum dem entsprechend 0-1=-1.

Die Darstellung und Funktionen eines einzelnen Freundes übernimmt die \textit{Friend}- Komponente, die ihre Daten als props übergeben bekommt.

Auch die Liste der Freundschaftsanfragen, die Liste der aktiven Spiele der \textit{ActiveGames}- oder \textit{Friend}-Komponente wird mittels der \verb|map()| Funktion durch einzelne Komponenten dargestellt.

\subsubsection{connected-Event}
\label{sec:connected}
Eine andere Interessante Methode der \textit{FriendList}-Komponente ist der Listener auf das \verb|connected| Event:

\begin{lstlisting}[style=codeStyle, caption={Der connected Eventlistener der \textit{FriendList}-Komponente}, label={lst:routing-Middlewares}]
socket.on('connected', (status, username) => {
    setFriends(prevFriends => {
        return [...prevFriends].map(friend => {
            if (friend.username === username) {
                friend.connected = status;
            }
            return friend;
        });
    });
});
\end{lstlisting}

Dieses Event wird ausgelöst, wenn ein Freund die Anwendung öffnet oder schließt beziehungsweise sich anmeldet oder abmeldet. Dabei wird die Freundesliste mit der Funktion \verb|map()| durchlaufen und der Status des entsprechenden Freundes wird aktualisiert. Der Code zum Senden dieses Events vom Backend wird in Kapitel \ref{sec:Backend-Socket} dargestellt.


\subsubsection{Nutzung von refreshKey}
\begin{lstlisting}[style=codeStyle, caption={Darstellung der Freundesliste in \textit{FriendList}}, label={lst:FriendList}]
//Home.js
...
const [refreshKey, setRefreshKey] = useState(0);
const refreshData = useCallback(() => {
    setRefreshKey((prevKey) => prevKey + 1);
}, [setRefreshKey, refreshKey]);

useEffect(() => {
    refreshData();
}, [location.pathname]);
...
//FriendList
useEffect(() => {
    socket.emit('get_friends', ({friendList}) => {
        setFriends(friendList);
    });
    socket.emit('get_friend_requests', ({requests}) => {
        setFriendRequests(requests);
    });
}, [socket, props.refreshKey]);
\end{lstlisting}

\verb|refreshKey| ist ein State, welcher den Komponenten \textit{FriendList} und \textit{ActiveGames} übergeben wird. Dieser State ist dient dazu die Freundesliste, Freundschaftsanfragen und aktive Partien aus dem Backend zu holen und zu aktualisieren. Wird beispielsweise von der \textit{ChessGame}-Komponente auf die \textit{Home}-Komponente navigiert, werden die Komponenten neu gerendert, doch die \verb|useEffect|-Hooks werden nur neu ausgeführt, wenn eines der Elemente im Dependency Array geändert wurde. Um sicherzustellen, dass die Daten ordnungsgemäß aktualisiert werden wird der \verb|refreshKey| dem Dependency Array hinzugefügt.


\subsection{Design}
\label{sec:Design}
In diesem Abschnitt geht es um Code-Beispiele des Frontend Designs mittels Chakra UI.  Wie schon in der Zielsetzung \ref{sec:Zielsetzung} besprochen ist das Design bisher nicht responsiv.

Chakra UI stellt Komponenten zum Gestalten zur Verfügung, so ist zum Beispiel die Komponente \verb|<Box>| vergleichbar mit einer \verb|<div>| Komponente und \verb|<Text>| mit \verb|<p>|. Diesen Komponenten lassen sich Attribute geben, um die Anpassbarkeit der Elemente zu erhöhen.

\begin{lstlisting}[style=codeStyle, caption={Darstellung der \textit{Friendlist} und \textit{ActiveGames} Komponenten in der \textit{Home}-Komponente}, label={lst:impl-Home}]
...
const backgroundBox = useColorModeValue("white", "purple.500");
...
{user.loggedIn === true ?
<Box backgroundColor={backgroundBox} borderRadius="md" marginLeft={3} p={6}
     boxShadow="0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)">
    <Text marginBottom={1} fontSize="1.2rem"> Active Games: </Text>
    <ActiveGames refreshKey={refreshKey}/>
    <Text marginTop={5} fontSize="1.2rem"> Friends: </Text>
    <FriendList refreshKey={refreshKey} times={times}/>
</Box>
:
<>
</>
}
\end{lstlisting}

In diesem Codeausschnitt der \textit{Home}-Komponente wird die \textit{FriendList} und \textit{ActiveGames} gerendert siehe Abbildung \ref{fig:home-logged-in}).

Verwendet wird der Ternäre Operator, um die Komponenten nur anzuzeigen, falls der Benutzer angemeldet ist (siehe Zeile 4 des Codeausschnitts \ref{lst:implHome}). Ist er nicht angemeldet wird das React Fragment \verb|<> </>| gerendert. Ein React Fragment ermöglicht die Gruppierung von Komponenten ohne einen \verb|<div>| Block verwenden zu müssen, da das React Fragment nicht in der DOM gerendert wird\footnote{Quelle: \url{https://react.dev/reference/react/Fragment} am 11. Mai 2023}.  In diesem Fall dient das React Fragment dazu, nichts zu rendern, falls der Benutzer nicht angemeldet ist.

Die Chakra UI Syntax für die Attribute einer Komponente erinnert an die CSS Syntax. So steht das Attribut \verb|p={6}| für das Padding \footnote{Quelle: \url{https://chakra-ui.com/docs/styled-system/style-props} am 11. Mai 2023}. Es handelt sich dabei allerdings nicht um sechs Pixel, sondern Chakra UI verwendet seine eigene Größenzuordnung. In diesem Fall entspricht das 1.5rem.

Um die Anwendung sowohl in einem dunklen Modus, als auch einem hellen Modus anzupassen, gibt es die Funktion \verb|useColorModeValue|\footnote{Quelle: \url{https://chakra-ui.com/docs/styled-system/color-mode} am 11. Mai 2023}. Diese Funktion lässt uns Werte je nach Modus definieren. In unserem Beispiel hat die \verb|<Box>|-Komponente die Hintergrundfarbe Weiß im hellen Farbschema und Lila im dunklen Farbschema.

\begin{lstlisting}[style=codeStyle, caption={Verwendung von einem Thema mit Chakra UI}, label={lst:themes.js}]
//App.js
...
<ChakraBaseProvider theme={customTheme}>
    ...
</ChakraBaseProvider>
...

//themes.js
const customTheme = extendTheme({
    overrides,
    fonts: {
        heading: `'Exo 2', sans-serif`,
        body: `'Exo 2', sans-serif`,
    },
    components: {
        Button: {
            variants: {
                'start-game-light': {
                    bg: "gray.200",
                    color: "black",
                    _hover: {
                        bg: "purple.200",
                    }
                },
                'start-game-dark': {
                    bg: "purple.700",
                    color: "white",
                    _hover: {
                        bg: "purple.600"
                    }
                },
                ...
//Home.js
...
const startGameButton = useColorModeValue("start-game-light", "start-game-dark");
...
<Button variant={startGameButton} ... > {time.string} </Button>
...
\end{lstlisting}

Chakra UI ermöglicht die Verwendung eines Themas, auf die man in allen Unterkomponenten der \textit{ChakraBaseProvider}-Komponente (siehe Abschnitt \ref{sec:React-Komponenten}) zugreifen kann\footnote{Quelle: \url{https://chakra-ui.com/docs/styled-system/customize-theme} am 11. Mai 2023}. In dem Beispielcode sieht man die Definition von zwei verschiedenen Buttons, die die Optik der Knöpfe in der \textit{Home}-Komponente zum Starten eines Spiels definieren. Diese Optik wird in einigen anderen Komponenten wiederverwendet, weshalb sie in der \verb|themes.js| Datei definiert werden, um eine bessere Wartbarkeit, Anpassbarkeit und Wiederverwendbarkeit zu gewährleisten.


    \section{Backend-Entwicklung}
    \subsection{Authentifizierung}
    \label{sec:Backend-auth-impl}
Die Vorgehensweise im Backend bei der Authentifizierung des Benutzers ist im Kapitel \ref{sec:Authentifizierung Backend} geschildert. In diesem Kapitel werde ich Code Beispiele vorstellen und erläutern.

\subsubsection{Routing-Middlewares}
Der Codeausschnitt \ref{lst:routing-Middlewares} zeigt die Reihenfolge der Middlewares bei den Anmelde- und Registrierungsanfragen des Frontends.
\begin{lstlisting}[style=codeStyle, caption={Ausschnitt aus index.js und die Datei authRouter.js}, label={lst:routing-Middlewares}]
//index.js
...
app.use("/auth", authRouter);
...

//authRouter.js
const express = require('express');
const router = express.Router();
... //import der Middlewares

router.use(rateLimiter(60, 10));

router.route('/login').get(handleLogin).post(validateLogin, attemptLogin);

router.post('/signup', validateSignUp, attemptSignUp);

router.get('/logout', handleLogout);

module.exports = router;
\end{lstlisting}

Für jede Anfrage auf den Pfad \verb|/auth| wird die Middleware \verb|rateLimiter| verwendet (siehe Zeile 11 des Codeausschnitts \ref{lst:routing-Middlewares}). Dieser achtet darauf, dass nicht zu viele Anfragen einer IP Adresse gesendet werden. 

\begin{lstlisting}[style=codeStyle, caption={Die rateLimiter Middleware}, label={lst:rateLimiter}]
const redisClient = require("../redis/redis.js");

module.exports.rateLimiter = (secondsLimit, limitAmount) => async (req, res, next) => {
    const ip = req.connection.remoteAddress;
    [response] = await redisClient
        .multi()
        .incr(ip)
        .expire(ip, secondsLimit)
        .exec();
    if (response[1] > limitAmount) {
        res.json({
            loggedIn: false,
            message: "Slow down!! Try again in a minute.",
        });
    }
    else next();
};
\end{lstlisting}

Der \verb|rateLimiter| nimmt die Argumente secondsLimit als Zeitfenster und limitAmount als Anfragelimit an und definiert mit Hilfe von ihnen die Middleware. Dafür nutzt er Redis und setzt mit der IP-Adresse als Key die Zahl der Anfragen als Value\footnote{Quelle: \url{https://redis.io/commands/incr/} am 11. Mai 2023}. Dieser Eintrag wird nach Ablauf des Zeitfensters gelöscht und falls das Anfragelimit innerhalb dieses Zeitfensters überschritten wurde, wird eine Fehlermeldung gesendet. Andernfalls wird die nächste Middleware aufgerufen.

In unserer Anwendung legen wir fest, dass 10 Anfragen innerhalb von 60 Sekunden gesendet werden dürfen.

Für die erste Authentifizierung im \textit{UserContext} (siehe Abschnitt \ref{sec:Cookie-auth}) wird die Middleware \verb|handleLogin| verwendet (siehe Zeile 13 des Codeausschnitts \ref{lst:routing-Middlewares}).

\begin{lstlisting}[style=codeStyle, caption={Die handleLogin Middleware zum Authentifizieren mit Cookie}, label={lst:handleLogin}]
const getJwtFromCookie = req => {
    return req.headers["cookie"] && cookie.parse(req.headers["cookie"])["jwt"];
};

module.exports.handleLogin = (req, res) => {
    const token = getJwtFromCookie(req);
    if(!token) {
        res.json({loggedIn: false});
    } else {
        jwt.verify(token, process.env.JWT_SECRET, (err, decodedPayload) => {
            if (err) {
                res.json({loggedIn: false});
            } else {
                res.json({loggedIn: true, username: decodedPayload.username});
            }
        });
    }
};
\end{lstlisting}

Diese Middleware ließt gegebenenfalls den Cookie mit dem JWT-Token und antwortet entsprechend ob er ihn erfolgreich dekodieren konnte oder nicht.

Bei den POST Anfragen des Frontends, über die das ausgefüllte Anmelde-, beziehungsweise Registrierungsformular gesendet wird, wird vor der Auswertung mit den Middlewares \verb|validateLogin| oder \verb|validateSignUp| überprüft, ob das Formular auch dem entsprechenden Yup Schema übereinstimmt. Anschließend wird mit \verb|attemptLogin| oder \verb|attemptSignUp| versucht den Benutzern anzumelden oder zu registrieren.

\begin{lstlisting}[style=codeStyle, caption={Die attemptLogin Middleware zum Anmelden}, label={lst:attemptLogin}]
module.exports.attemptLogin = async (req, res) => {
    const potentialLogin = await query(
        "SELECT id, username, password, userid FROM users u WHERE u.username=$1",
        [req.body.username]
    );
    if (potentialLogin.rowCount > 0) {
        const isSamePassword = await bcrypt.compare(
            req.body.password,
            potentialLogin.rows[0].password
        );
        if (isSamePassword) {
            const user = {
                username: req.body.username,
                userid: potentialLogin.rows[0].userid,
            }
            jwt.sign(
                user,
                process.env.JWT_SECRET,
                {expiresIn: "24h"},
                (err,token) => {
                if(err) {
                    res.json({loggedIn: false, message: "Something went wrong, try again later"});
                } else {
                    const jwtCookie = cookie.serialize("jwt", token, {
                        httpOnly: true,
                        secure: process.env.NODE_ENV === "production", // Secure flag only in production
                        maxAge: 24 * 60 * 60, // 24 hours
                        sameSite: "lax",
                        path: "/"
                    });
                    res.setHeader("Set-Cookie", jwtCookie);
                    res.json({loggedIn: true,  username: user.username});
                }
            }
            );
        } else {
            res.json({loggedIn: false, message: "Wrong username or password!"});
        }
    } else {
        res.json({loggedIn: false, message: "Wrong username or password!"});
    }
};
\end{lstlisting}

Die Middleware \verb|attemptLogin| überprüft zunächst, ob ein Benutzer mit diesem Benutzernamen in der PostgreSQL-Datenbank existiert und mittels bcrypt ob die Passwörter übereinstimmen. Dafür wird die \verb|query|-Funktion (siehe Kapitel \ref{sec:Datenbank-Integration}) genutzt, indem in der Tabelle \verb|users| nach einem Eintrag mit dem Benutzernamen gesucht wird. Der SQL-String verwendet den Platzhalter \verb|$1|, der durch den Wert \verb|[req.body.username]| ersetzt wird\footnote{Quelle: \url{https://node-postgres.com/features/queries} am 11. Mai 2023}. Existiert kein Benutzer mit diesem Benutzernamen oder ist das Passwort falsch wird das Frontend darüber benachrichtigt. Ansonsten wird ein 24 Stunden haltbarer JWT-Token mit dem Benutzernamen und der \verb|userid| generiert und in einen Cookie mit dem Key \glqq jwt\grqq{ }gesetzt, welcher ebenfalls 24 Stunden gültig ist. Der JWT-Token beinhaltet die \verb|userid|, da die Socket Verbindung diese Information beim authentifizieren benötigt (siehe Abschnitt \ref{sec:Backend-Socket}).  Wichtig dabei ist, dass das Attribut \verb|httpOnly| auf \verb|true| gesetzt wird, um zu verhindern, dass Client seitiger Code auf den Cookie zugreifen könnte. Anschließend wird dem Frontend noch mit dem JSON Objekt geantwortet (siehe Zeile 39).

Beim Registrieren wird ebenfalls bei Erfolg der Cookie mit dem JWT-Token gesetzt, jedoch sind die Anforderungen natürlich andere. Es wird überprüft, ob bereits ein Account mit dem Benutzernamen oder der E-Mail existiert und falls ja wird dem Frontend entsprechend geantwortet. Ansonsten wird eine zufällige \verb|userid| erstellt, das Passwort mit bcrypt verschlüsselt, der Tupel in der Datenbank gespeichert und der Cookie mit dem JWT-Token gesetzt.

\subsubsection{Abmelden}
Da das Abmelden auch gewissermaßen zum Authentifizierungsprozess gehört, wird hier kurz beschrieben, was im Backend dabei passiert.

\begin{lstlisting}[style=codeStyle, caption={Middleware zum Abmelden}, label={lst:handleLogout}]
module.exports.handleLogout = (req, res) => {
    res.setHeader(
        "Set-Cookie",
        cookie.serialize("jwt", "", {
            httpOnly: true,
            secure: process.env.NODE_ENV === "production",
            maxAge: -1,
            sameSite: "lax",
            path: "/"
        })
    );
    res.sendStatus(204);
}
\end{lstlisting}

Eine Anfrage zum Abmelden wird auf den Pfad \verb|auth/logout| gestellt unter der die Middleware aus Codeausschnitt \ref{lst:handleLogout} durchlaufen wird. In dieser wird ein leerer (siehe Zeile 4), abgelaufener(siehe Zeile 7) \glqq jwt\grqq -Cookie gesetzt, der bewirkt, dass der bisherige \glqq jwt\grqq -Cookie gelöscht wird. Dann wird dem Frontend mit dem Code 204 geantwortet (siehe Zeile 12), welcher aussagt, dass die Anfrage erfolgreich bearbeitet wurde, jedoch keine Daten mit der Antwort gesendet werden\footnote{Quelle \url{https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204} am 05. Mai 2023}.

\subsubsection{Socket.io Authentifizierung und Middleware}
\label{sec:Backend-Socket}
Im Codeausschnitt \ref{lst:index.js-socket} ist ein Ausschnitt der index.js Datei zu sehen, in der der Socket.io Server initialisiert wird und die Middlewares für socket Verbindungen zugewiesen werden.

\begin{lstlisting}[style=codeStyle, caption={Ausschnitt der index.js Datei mit Socket.io Server Erstellung und Middleware Zuweisung}, label={lst:index.js-socket}]
...
const corsConfig = {
    origin: process.env.FRONTEND_URL,
    credentials: true,
}
const server = require('http').createServer(app);
const io = new Server(server, {
    cors: corsConfig
});
io.use(authorizeUser);
io.use(initializeUser);
io.use((socket, next) => {
    initializeChessListeners(socket, io);
    initializeListeners(socket, io);
    next();
});
...
\end{lstlisting}

Die Initilaisierung des Socket.io Servers benötigt die \verb|corsConfig| Konfiguration, um Verbindungen vom Frontend zuzulassen und Header Informationen wie Cookies mitzusenden.

Es werden drei Middlewares bei einem Verbindungsaufbau durchlaufen,  die ich in diesem Kapitel mit Codeausschnitten erläutern werde.


\begin{lstlisting}[style=codeStyle, caption={authorizeUser Middleware für Socket.io Verbinudngen}, label={lst:authorizeUser}]
module.exports.authorizeUser = (socket, next) => {
    let token = null;
    if (socket.request.headers.cookie) {
        token = cookie.parse(socket.request.headers.cookie).jwt;
        if (token) {
            jwt.verify(token, process.env.JWT_SECRET, (err, decodedPayload) => {
                if (err) {
                    next(new Error('Unable to Read Token'));
                    return;
                }
                socket.user = {...decodedPayload};
            });
        }
    }
    next();
}
\end{lstlisting}

Die Middleware \verb|authorizeUser| (siehe Codeausschnitt \ref{lst:authorizeUser}) authentifiziert den Benutzer. Dabei  wird auf den Cookie zugegriffen, der gegebenenfalls gesetzt wurde, um den Benutzernamen und die \verb|userid| als Attribute der socket zu setzen (siehe Zeile 11 des Codeausschnitts \ref{lst:authorizeUser}). Diese Middleware ist der Grund, warum immer eine neue Socket.io Verbindung hergestellt werden muss, sobald der Benutzerzustand und damit der Cookie sich verändert. Ansonsten könnte es sein, dass veraltete Informationen in \verb|socket.user| definiert sind.

\begin{lstlisting}[style=codeStyle, caption={initializeUser Middleware für Socket.io Verbinudngen}, label={lst:initializeUser}]
module.exports.initializeUser = async (socket, next) => {
    if (socket.user) {
        socket.join(socket.user.userid);
        await setUser(socket.user.username, socket.user.userid, true);
        getFriends(socket.user.username).then(async friends => {
            const friendRooms = friends.map(friend => friend.userid);
            if (friendRooms.length > 0) {
                socket.to(friendRooms).emit("connected", "true", socket.user.username);
            }
        });
    }
    next();
};
\end{lstlisting}

In der Middleware \verb|initializeUser| wird der Nutzer als online vermerkt, seine Freunde werden darüber informiert, dass er nun online ist und er tritt dem Raum seiner \verb|userid| bei. Dies passiert natürlich nur, wenn in der vorherigen Middleware der Benutzer authentifiziert werden konnte. Die Funktion \verb|setUser| setzt den Eintrag \verb|user:username| mit der \verb|userid| und \verb|connected| auf true. Die Methode \verb|getFriends| (siehe Kapitel \ref{ref:getFriends}) holt die Benutzernamen und die \verb|userid|s aller Freunde des Benutzers und mittels der map Funktion wird an alle \verb|userid|s der Freunde das Event \verb|connected| gesendet. Dadurch wird im Frontend der Spieler als online angezeigt (siehe Abschnitt \ref{sec:connected}). 

Die dritte Middleware setzt alle nötigen Listener für Events, die mit dem Schachspiel zusammenhängen, als auch sonstige Funktionen (siehe Zeilen 12 ff. des Codeausschnitts \ref{lst:index.js-socket}).

\begin{lstlisting}[style=codeStyle, caption={Die onDisconnect Methode für Sockets}, label={lst:onDisconnect}]
module.exports.onDisconnect = async (socket) => {
    if (!socket.user) {
        return;
    }
    await setUser(socket.user.username, socket.user.userid, false);
    getFriends(socket.user.username).then(friends => {
        const friendRooms = friends.map(friend => friend.userid);
        if (friendRooms.length > 0) {
            socket.to(friendRooms).emit("connected", "false", socket.user.username);
        }
    });
}
\end{lstlisting}

Die \verb|onDisconnect| Methode aus Codeausschnitt \ref{lst:onDisconnect} wird aufgerufen, sobald eine socket Verbindung getrennt wird. Hierfür dient der \verb|socket.disconnect()| Aufruf des Frontends (siehe Abschnitt \ref{sec:socket-Verbindung}). Ähnlich wie bei der \verb|initializeUser| Middleware (siehe Codeausschnitt \ref{lst:initializeUser}) wird dabei in Redis der Spieler als offline vermerkt und seine Freunde werden mit dem Event \verb|connected| darüber in Kenntnis gesetzt.


\subsection{Das Schachspiel}
\label{sec:Schach-Backend-impl}
Das Schachspiel verwaltet die Datei \verb|socketChessController.js|, welche eine der Funktionen zur Listener Initialisierung bereitstellt (siehe \verb|initilializeChessListeners| aus Codeausschnitt \ref{lst:index.js-socket}), wobei \verb|ServerChessClock.js| die Schachuhren bereitstellt.

In diesem Abschnitt werde ich einige Aspekte der Implementierung des Schachspiels mit Code Beispielen erläutern. Funktionen wie Aufgeben, das Ende der Partie oder Chat Nachrichten werden im Abschnitt \ref{sec:Schach-Backend} erläutert und zeichnen sich durch geringere Komplexität aus, weshalb sie in diesem Abschnitt nicht nochmals behandelt werden. Auch das Finden eines Gegners wird in dem Abschnitt der Backend-Architektur detailliert beschrieben, weshalb dies hier nicht noch einmal erläutert wird.

\subsubsection{Initialisierung eines Spiels}
\label{sec:init-backend}
Die Suche und das Finden eines Gegners wurde in Abschnitt \ref{sec:find_game} erläutert. In diesem Abschnitt möchte ich genauer darauf eingehen, wie ein Spiel nach gefundenem Gegner initialisiert wird. Dabei handelt es sich um die \verb|createChessGame| Methode (für Kontext siehe Sequenzdiagramm in Abbildung \ref{fig:sequence_chess_start}).

\begin{lstlisting}[style=codeStyle, caption={Die createChessGame Methode zum Initialisieren einer Schachpartie}, label={lst:createChessGame}]
const createChessGame = async (io, username1, username2, time) => {
    const roomId = UUIDv4();
    const [whitePlayer, blackPlayer] = Math.random() < 0.5 ? [username1, username2] : [username2, username1];

    const chessInstance = await import('../chess/Chess.mjs').then(ChessFile => {
        return ChessFile.Chess();
    });
    const d = new Date();
    chessInstance.header('White', whitePlayer, 'Black', blackPlayer, 'Date', d.toDateString());
    //Store Game in Redis
    await initializeGame(roomId, whitePlayer, blackPlayer, time, chessInstance.pgn());
    const chessClock = new ServerChessClock(time);
    currentChessClocks[roomId] = {chessClock};

    chessClock.startStartingTimer('white');
    chessClock.ChessClockEvents.on('cancel_game', () => {
        io.to(roomId).emit('cancel_game');
        io.to(roomId).emit('stop_clocks');
        endGame(roomId)
    });
    chessClock.ChessClockEvents.on('time_over', (color) => {
        io.to(roomId).emit('time_over', color);
        io.to(roomId).emit('stop_clocks');
        endGame(roomId);
    });
    return roomId;
}
\end{lstlisting}

Die \verb|createChessGame| Methode legt zunächst per Zufall fest, welcher Spieler welche Farbe spielen soll und generiert eine zufällige ID als roomId in der das Spiel stattfindet. Anschließend wird ein chess.js Objekt erstellt. Da es sich bei der Bibliothek chess.js um ein ECMAScript-Module handelt und node.js ein CommonJS-Modulsystem verwendet muss man einen Umweg mittels einer \verb|.mjs|-Datei zum Importieren der Bibliothek verwenden\footnote{Quelle: \url{https://stackoverflow.com/questions/70396400/how-to-use-es6-modules-in-commonjs} am 06. Mai 2023} (siehe Codeausschnitt \ref{lst:Chess.mjs}).

\begin{lstlisting}[style=codeStyle, caption={Die Chess.mjs Datei}, label={lst:Chess.mjs}]
import {Chess as ChessGame} from 'chess.js';
export const Chess = () => new ChessGame();
\end{lstlisting}

Mit diesem chess.js Objekt generieren wir eine PGN-Notation, in die die Benutzernamen der Spieler und das Datum eingetragen sind. Diese Informationen werden mittels der \verb|initializizeGame| Methode in Redis unter \verb|game:roomId| gespeichert. Falls die Spieler angemeldet sind wird die roomId auch in die Listen \verb|activeGames| der \verb|user:username| Einträge der beiden Spieler hinzugefügt. 

Des weiteren wird ein ServerChessClock Objekt erstellt und in \verb|currentChessClock| mit der roomId als Key gespeichert. Die Kommunikation und der Aufbau von ServerChessClock wird in Abschnitt \ref{sec:Uhr-Backend-impl} erläutert.
Eventlistener für die Events \verb|time_over| und \verb|cancel_game| der ServerChessClock werden definiert. \verb|cancel_game| ist ein Event, welches ausgelöst wird, falls eine Startzeit abgelaufen ist und \verb|time_over|, falls eine reguläre Zeit abgelaufen ist.
Da die Schachuhren und das Schachspiel möglichst Modular gehalten werden, wird an das Frontend in diesen Listenern immer zwei Events gesendet: \verb|time_over|, beziehungsweise \verb|cancel_game| für das Schachspiel und \verb|stop_clocks| für die Schachuhren im Frontend. Bei jeder Möglichkeit wie eine Schachpartie endet wird definiert, dass die Funktion \verb|endGame| ausgeführt werden soll, so auch bei diesen zwei Listenern. Was bei diese Methode bewirkt wird in Kapitel \ref{sec:Schach-Ende} erläutert.

\subsubsection{Neue Züge}
\label{sec:new_move_backend}
Beim Eingang eines neuen Zugs mittels des \verb|new_move| Events wird die Methode \verb|newMove| ausgeführt. Sie benötigt die socket des Spielers und die Socket.io Server Instanz. Die restlichen Daten die sie benötigt werden vom Frontend mit dem Event mitgesendet.

Ein Aktivitätsdiagramm und eine ausführliche Erklärung des Ablaufs wird in Abschnitt \ref{sec:Zug-Backend} behandelt. In diesem Abschnitt konzentrieren wir uns auf die Umsetzung dieser Aktivitäten im Code.
\begin{lstlisting}[style=codeStyle, caption={newMove Methode die beim Eingang eines neuen Zugs aufgerufen wird}, label={lst:newMove}]
//Listener:
client.on('new_move', newMove(client, io));
//Methode
const newMove = (socket, io) => async (roomId, player, move, cb) => {
    if(!currentChessClocks[roomId]) {
        cb({done: false, errMsg: "Game does not exist"});
        return;
    }
    const {chessClock} = currentChessClocks[roomId];
    const chessInstance = await import('../chess/Chess.mjs').then(ChessFile => {
        return ChessFile.Chess();
    });
    try {
        chessInstance.loadPgn(await getGame(roomId, "pgn").then(pgn => {
            if(!pgn) {
                cb({done: false, errMsg: "Game does not exist"});
                return;
            }
            return pgn;
        }));
        chessInstance.move(move)
    } catch(error) {
        cb({done: false, errMsg: error});
        return;
    }
	
    socket.to(roomId).emit('opponent_move', move);
    //Store move in Redis
    newChessMove(chessInstance.pgn(), roomId).then(r => cb({done: true}));
    
    if(chessInstance.isGameOver()) {
        if (chessInstance.isCheckmate()) {
            io.to(roomId).emit('checkmate', socket.user.username);
        } else {
            io.to(roomId).emit('draw');
        }
        io.to(roomId).emit('stop_clocks');
        chessClock.ChessClockEvents.emit('stop');
        endGame(roomId);
        cb({done: true});
        return;
    }
    
    chessClock.ChessClockEvents.emit('toggle', ({remainingTimeWhite, remainingTimeBlack, turn}) => {
        io.to(roomId).emit('updated_time', remainingTimeWhite, remainingTimeBlack, turn);
    });

    if (chessInstance.history().length === 1) {
        chessClock.startStartingTimer('black');
        io.to(roomId).emit('stop_starting_time_white');
    } else if (chessInstance.history().length === 2) {
        chessClock.startTimer('white');
        io.to(roomId).emit('stop_starting_time_black');
    }
}
\end{lstlisting}

Die Methode holt erst das ServerChessClock Objekt aus dem \verb|currentChessClocks| Array und importiert die aktuelle PGN-Notation des Schachspiels aus der Redis Datenbank in ein chess.js Objekt und macht den Zug darauf (siehe Zeilen 5 - 25 des Codeausschnitts \ref{lst:newMove}).

Die Kommunikation mit dem Frontend erfolgt über verschiedene Events wie \linebreak \verb|opponent_move|, \verb|checkmate|, \verb|draw|, \verb|stop_clocks|, \verb|updated_time|,  \linebreak \verb|stop_starting_time_white| und \verb|stop_starting_time_black|. Diese Events behandeln entweder ein Ereignis der Schachpartie oder verwalten die Schachuhren. Über die Callback Funktion wird mitgeteilt, ob der Zug erfolgreich behandelt werden konnte oder nicht.

Mit dem ServerChessClock Objekt wird mittels der Events \verb|stop| und \verb|toggle| (siehe Abschnitt \ref{sec:Uhr-Backend-impl}) und den Funktionsaufrufen \verb|startStartingTimer| und \verb|startTimer| kommuniziert. \verb|stop| wird bei einem Ende der Partie gesendet, \verb|toggle| bei jedem neuen Zug, es sei denn das Spiel ist vorbei und die Funktionsaufrufe dienen zum initialen starten der Startuhren oder der regulären Uhr.

Des weiteren wird die aktualisierte PGN-Notation des Spiels mit der Funktion \linebreak \verb|newChessMove| (siehe Zeile 28 im Codeausschnitt \ref{lst:onMove}) in Redis gespeichert.

\subsubsection{Senden des aktuellen Zustands einer Partie}
Beim Laden der \textit{ChessGame}-Komponente im Frontend wird das Event \verb|get_game_data| gesendet, um den aktuellen Zustand des Spiels zu erhalten und spielen zu können beziehungsweise zugucken zu können. 


\begin{lstlisting}[style=codeStyle, caption={Der Listener des get\_game\_data Events zum übermitteln des Schachspiels}, label={lst:get_game_data}]
client.on('get_game_data', (roomId, guestName, cb) => {
    if (!currentChessClocks[roomId]) {
        cb({done: false, errMsg: "This Game does not exist"});
        return;
    }
    const {chessClock} = currentChessClocks[roomId];
    if (!client.rooms.has(roomId)) {
        client.join(roomId);
    }
    if(guestName) {
        client.user = {username: guestName}
    }
    getGame(roomId)
        .catch(() => {
            cb({done: false, errMsg: "This Game does not exist"})
        })
        .then(game => {
                if (!game) {
                    cb({done: false, errMsg: "This Game does not exist"});
                    return;
                }
                game.currentState = chessClock.getCurrentMode();
                if (game.currentState.includes('s')) {
                    game.currentStartingTimer = chessClock.getCurrentStartingTimer();
                } else {
                    game.currentTimes = chessClock.getCurrentTimes();
                }
                cb({done: true, data: game});
            }
        )
});
\end{lstlisting}

Es gibt zwei Szenarien, in denen kein Zustand des Schachspiels gesendet werden kann: Falls kein ServerChessClock Objekt in dem \verb|currentChessClocks| Array vorhanden ist (siehe Zeile 2 des Codeausschnitts \ref{lst:get_game_data}) oder falls kein Redis Eintrag zu diesem Spiel gefunden werden konnte (siehe Zeile 15 \& 18 des Codeausschnitts \ref{lst:get_game_data}).

Essenziell bei diesem Listener ist, dass die socket gegebenenfalls der roomId beitritt, um zukünftige Events, wie neue Züge, erhalten zu können. Außerdem ist es wichtig den Benutzernamen zu setzen, falls es sich um einen Gast handelt. Denn wenn dieser die Seite neu lädt wird eine neue socket Verbindung hergestellt und der Gast-Benutzername wäre nicht mehr in der socket gespeichert. Allerdings wird auf den Benutzernamen der socket beispielsweise bei einem Schachmatt zugegriffen.

Die aktuellen Daten, wie welcher Spieler welche Farbe spielt und die aktuelle PGN-Notation des Spiels werden aus Redis mittels der Funktion \verb|getGame| aus \verb|game:roomId| geholt. Fehlen nur noch die aktuellen Zeiten. Dafür verwenden wir \verb|getCurrentMode()|, um den aktuellen Zustand der Schachuhren zu bekommen (siehe Zeile 23). Dieser besteht wie im Frontend aus \glqq tw\grqq , \glqq tb\grqq , \glqq sw\grqq{ }und \glqq sb\grqq{ }(siehe \ref{sec:impl-schachuhr}). 

Je nachdem welche Uhren gerade laufen werden entweder die Startzeiten oder die reguären Zeiten der Spieler den Redis Daten hinzugefügt und anschließend dem Frontend per Callback Funktion übermittelt.

Hier wird der Sinn hinter der Speicherung des ServerChessClock Objekts in einem Array ersichtlich. Um die aktuelle Zeit abzurufen muss auf das ServerChessClock Objekt zugegriffen werden. Eine Kritik dieser Speicherungder aktuellen Zeiten und Alternativen werden in Abschnitt \ref{sec:herausforderung-Schachuhr} erläutert.

\subsubsection{Die Uhr}
\label{sec:Uhr-Backend-impl}
Die serverseitige Schachuhr wird von Objekten der Klasse \verb|ServerChessClock| verwaltet. Diese Objekte besitzen die folgenden Attribute:

\begin{lstlisting}[style=codeStyle, caption={Konstruktor der ServerChessClock Klasse}, label={lst:const-ServerChessClock}]
function ServerChessClock(time) {
    this.timeMode = time;
    this.currentMode = 'off';
    this.remainingTimeWhite = {minutes: time.minutes, seconds: 0};
    this.remainingTimeBlack = {minutes: time.minutes, seconds: 0};
    this.ChessClockEvents = new EventEmitter();
    this.startingTimeWhite = {seconds: 0};
    this.startingTimeBlack = {seconds: 0};
    switch (time.type) {
        case 'Bullet': this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = 15; break;
        case 'Blitz': this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = 20; break;
        case 'Rapid': this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = 30; break;
        case 'Classical': this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = 45; break;
        default: this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = "unknown"; break;
    }
}
\end{lstlisting}

Vorab stelle ich vor, wie ein \verb|time| (siehe Zeile 1 des Codeausschnitts \ref{lst:const-ServerChessClock}) Objekt aufgebaut ist:
\begin{verbatim}
{type: 'Rapid', minutes: 15, increment: 10, string: '15 + 10'}
\end{verbatim}
\verb|type| Klassifiziert die Schachuhr Konfigurationen zu verschiedenen Modi. Diese Klassifikationen der Schachuhren sind auf online Schach-Plattformen wie \url{lichess.org} bereits Standard. Die Gründe dafür liegen vor allem in der Erweiterbarkeit (siehe //REF). Bisher werden sie genutzt um wie in Zeilen 9 ff. des Codeausschnitts \ref{lst:const-ServerChessClock} verschieden lange Startzeiten zu initialisieren.

\verb|string| dient der Darstellung und der einfachen Identifizierung dieser Objekte.

\begin{lstlisting}[style=codeStyle, caption={Die startTimer und stopCurrentGame Methoden der ServerChessClock Klasse}, label={lst:startTimer}]
ServerChessClock.prototype.startTimer = function (color) {
    this.currentMode = color === "white" ? "tw" : "tb";
    const currentPlayerTime = color === "white" ? this.remainingTimeWhite : this.remainingTimeBlack;


    const isTimeOver = () => {
        return currentPlayerTime.minutes === 0 && currentPlayerTime.seconds === 0;
    };

    const decreaseTime = () => {
        if (currentPlayerTime.seconds === 0) {
            currentPlayerTime.minutes -= 1;
            currentPlayerTime.seconds = 59;
        } else {
            currentPlayerTime.seconds -= 1;
        }
    };

    const timer = setInterval(() => {
        decreaseTime();
        if (isTimeOver()) {
            clearInterval(timer);
            this.stopCurrentGame();

        }
    }, 1000);
    
	//If game ends, because player resigned, checkmate, ...
    this.ChessClockEvents.once("stop", () => {
        clearInterval(timer);
    });
    
    //If a player played a new move
    this.ChessClockEvents.once("toggle", (cb) => {
        clearInterval(timer);
        if (color === "white") {
            this.remainingTimeWhite = increment(
                currentPlayerTime,
                this.timeMode.increment
            );
            cb({
                remainingTimeWhite: this.remainingTimeWhite,
                remainingTimeBlack: this.remainingTimeBlack,
                turn: "tb",
            });
            this.startTimer("black");
        } else {
            this.remainingTimeBlack = increment(
                currentPlayerTime,
                this.timeMode.increment
            );
            cb({
                remainingTimeWhite: this.remainingTimeWhite,
                remainingTimeBlack: this.remainingTimeBlack,
                turn: "tw",
            });
            this.startTimer("white");
        }
    });
};

ServerChessClock.prototype.stopCurrentGame = function () {
    if (this.getCurrentMode().includes('s')) {
        this.ChessClockEvents.emit('cancel_game');
    } else if (this.getCurrentMode().includes('w')) {
        this.ChessClockEvents.emit('time_over', 'white');
    } else {
        this.ChessClockEvents.emit('time_over', 'black');
    }
}
\end{lstlisting}

Die Funktion \verb|startTimer| wird ein mal von \verb|SocketChessController| aufgerufen, falls der zweite Zug gespielt wurde (siehe Zeile 52 des Codeausschnitts \ref{lst:newMove}). Anschließend wird die Methode selbst rekursiv aufgerufen, falls ein neuer Zug gespielt wurde und das \verb|toggle| Event empfangen wurde (siehe Zeile 46 \& 57 im Codeausschnitt \ref{lst:startTimer}).

Je nachdem welche Zeit läuft, wird \verb|currentMode| aktualisiert und die entsprechende Zeit wird in \verb|currentPlayerTime| referenziert (siehe Zeilen 2 \& 3 des Codeausschnitts \ref{lst:startTimer}).

Die Zeit läuft durch den \verb|timer| ab, welcher \verb|setInterval| nutzt, um jede Sekunde mittels \verb|decreaseTime| die Zeit ablaufen zu lassen und \verb|isTimeOver| um zu überprüfen ob die Zeit abgelaufen ist (siehe Zeile 19 ff. des Codeausschnitts \ref{lst:startTimer}).

Es wird ein Listener auf das Event \verb|toggle| definiert, welcher bei einem neuen Zug das Inkrement auf die entsprechende Zeit rechnet und mittels Callback Funktion die aktuellen Zeiten durchgibt (siehe Zeilen 41 ff. und 52 ff. des Codeausschnitts \ref{lst:startTimer}), um diese in der \verb|newMove| Methode an das Frontend zu senden (siehe Kapitel \ref{sec:new_move_backend}). Dieser Listener wird mit \verb|ones(...)| definiert, wodurch er nur ein mal auf das Event hört. Dies ist wichtig, da anschließend die \verb|startTimer| Methode reukursiv aufgerufen wird und der Listener neu initialisiert wird.

Die \verb|stopCurrentGame| Methode wird aufgerufen, falls eine Zeit (Startzeit oder reguläre Zeit) abgelaufen ist und sendet entsprechende Events an SocketChessController. Wie diese Events empfangen werden ist in Codeausschnitt \ref{lst:createChessGame} enthalten.


\subsection{Verwaltung von Freunden}
\label{sec:Freunde-impl}
In diesem Kapitel zeige ich die Implementierung von dem Versenden von Freundschaftsanfragen und dem senden der Freunde an das Frontend. Die zugehörigen Redis Funktionen werden in Kapitel \ref{sec:Datenbank-Integration} eräutert.

Alle anderen Funktionen welche nicht mit dem Schachspiel und der Authentifizierung zusammenhängen werden durch die Listener in der Datei \verb|socketController.js| zur Verfügung gestellt und verwenden den \verb|redisController| für Operationen an der Redis Datenbank. Der Ablauf von Funktionen im Backend bezüglich Freunden wurde ausführlich in dem Kapitel \ref{sec:hinzufügen-von-Freunden} behandelt.

\subsubsection{Versenden einer Freundschaftsanfrage}
\label{sec:Freundschaftsanfrage-backend}
\begin{lstlisting}[style=codeStyle, caption={Der Listener des send\_friend\_request Events}, label={lst:sendFriendRequest}]
client.on('send_friend_request', (requestName, cb) => {
    if(client.user) {
        requestFriend(client.user.username, client.user.userid, requestName)
        .catch(err => {            
            cb({done: false, errorMsg: "Please try again later"});
            return;
        })
        .then(result => {
                if (result.errorMsg) {
                    cb({done: false, errorMsg: result.errorMsg});
                    return;
                }
                cb({done: true});
                client.to(result.userid).emit('friend_request', client.user.username);
            }
        );
    } else {
        cb({done: false, errorMsg: "Please try again later"});
    }
});
\end{lstlisting}

Die Funktion \verb|requestFried| der \verb|redisController| Datei überprüft, ob eine Freundschaft der beiden Spieler erlaubt wäre und gibt uns unter anderem die \verb|userid| des angefragten Spielers zurück und speichert die Freundschaftsanfrage in Redis (siehe Kapitel \ref{sec:requestFriend}). Ist die Freundschaft nicht erlaubt wird die entsprechende Fehlermeldung, warum sie nicht erlaubt ist an den Sender mittels Callback Funktion weitergeleitet. Ansonsten wird die Freundschaftsanfrage mittels des Events \verb|friend_request| an den Benutzer gesendet und der Sender wird über die Callback Funktion über den erfolgreichen Versand benachrichtigt.

\subsubsection{Das Senden der Freunde ans Frontend}
\label{sec:Senden-der-Freunde}
Beim rendern der \textit{Home}-Komponente werden Events vom Frontend gesendet, um Daten wie Freunde, Freundschaftsanfragen und aktive Spiele aus der Redis Datenbank mittels Callback Funktion zu holen. Eine davon ist das \verb|get_friends| Event.

\begin{lstlisting}[style=codeStyle, caption={Der get\_friends Listener}, label={lst:get_friends}]
    client.on('get_friends', async (cb) => {
        if(client.user) {
            const friends = await getFriends(client.user.username);
            const parsedFriends = await parseFriendList(friends);
            cb({friendList: parsedFriends});
        }
    });
\end{lstlisting}

Die \verb|get_friends| Methode liefert uns die Benutzernamen und \verb|userid|s aller Freunde (siehe Kapitel \ref{sec:getFriends}), allerdings benötigt das Frontend noch weitere Daten. Das sind die aktiven Partien des Benutzers und den Status ob er gerade online ist oder nicht. Diese Daten ergänzt die Methode \verb|parseFriendList| (siehe Kapitel \ref{sec:parseFriendList}).


\section{Datenbank Integration}
\label{sec:Datenbank-Integration}
Die Herstellung einer Verbindung zu der PostgreSQL und zu der Redis Datenbank wird jeweils in einer Datei hergestellt:

\begin{lstlisting}[style=codeStyle, caption={Initialisierung der PostgreSQL Datenbank und einer Methode für die Anfragen}, label={lst:pg-pool}]
require('dotenv').config()
const Pool = require('pg').Pool

const pool = new Pool({
    user: process.env.DATABASE_USER,
    host: process.env.DATABASE_HOST,
    database: process.env.DATABASE_NAME,
    password: process.env.DATABASE_PASSWORD,
    port: process.env.DATABASE_PORT,
})

const query = (text, params) => pool.query(text, params)
module.exports = { query }  
\end{lstlisting}

\begin{lstlisting}[style=codeStyle, caption={Initialisierung einer Redis-Datebank Verbindung}, label={lst:redisClient}]
const Redis = require('ioredis');

const redisClient = new Redis();

module.exports = redisClient;
\end{lstlisting}

Die Daten zum Herstellen einer Verbindung sind in einer \verb|.env| Datei gespeichert, um die Sicherheit und Wartbarkeit zu erhöhen, da .env Dateien standardmäßig zu Dateien zählen, welche nicht in Git aufgenommen werden.

Wie die PostgreSQL Datenbank genutzt wird ist in Kapitel \ref{sec:Backend-auth-impl} erläutert. 

\subsection{Zugriff auf Redis mit dem redisController}
Alle Operationen auf der Redis Datenbank werden von der Datei \verb|redisController| zur Verfügung gestellt (mit Ausnahme der \verb|rateLimiter| Middleware). Welche Datentypen unter welchen Keys in Redis gespeichert werden, wird in Abschnitt \ref{sec:redis-data} erläutert.
Die Datei enthält 19 Methoden, die fast alle auf die Datenbank zugreifen. In diesem Abschnitt werden exemplarisch einige wichtige Methoden vorgestellt.

\subsubsection{addPlayerInQueue}

\begin{lstlisting}[style=codeStyle, caption={Methode um einen Spieler in eine Warteschlange hinzuzufügen}, label={lst:addPlayerInQueue}]
module.exports.addPlayerInQueue = async (loggedIn, time, user) => {
    return new Promise((resolve, reject) => {
        const key = loggedIn === true ? `waitingPlayers${time}` : `waitingGuests${time}`;
            redisClient.lpush(key, `${user:username}:${user:userid}`, (err, result) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(result);
                }
            });
    });
};
\end{lstlisting}

Die \verb|addPlayerInQueue| Methode hat die Funktion einen Spieler in eine Warteschlange für einen zufälligen Gegner hinzuzufügen. Je nachdem ob er angemeldet ist oder nicht wird die Warteschlange \verb|waitingPlayers| oder \verb|waitingGuests| mit der entsprechenden Zeit als Key genutzt, um \verb|username:userid| in die Warteschlange zu schreiben.

Die Funktion \verb|lpush| fügt den Spieler am Anfang der Liste ein. Herausgenommen werden Spieler mittels der Funktion \verb|rpop|, die Spieler am Ende der Liste entnehmen. So wird gewährleistet, dass der Spieler der am längsten wartet zu erst entnommen wird.

Implementiert ist die Funktion durch eine \verb|Promise|, welche es ermöglicht eine Fehlerbehandlung oder ein Ergebnis einer asynchronen Methode getrennt zu behandeln\footnote{Quelle: \url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises?retiredLocale=de} am 14. Mai 2023}, beziehungsweise in diesem Fall weiter zu geben. 


\subsubsection{getFriends}
\label{sec:getFriends}
\begin{lstlisting}[style=codeStyle, caption={Methode um Freunde eines Spielers zu erhalten}, label={lst:getFriends}]
const getFriends = async (username) => {
    const friendList = await redisClient.lrange(`friends:${username}`, 0, -1);
    return friendList.map(friend => {
        return {username: friend.split(':')[0], userid: friend.split(':')[1]};
    });
}
\end{lstlisting}

Die Methode \verb|getFriends| holt alle Freunde eines Spielers aus dem key \verb|friend:username|. Mittels der Funktion \verb|lrange| können Elemente aus einer Liste geholt werden. Der Parameter \verb|0| repräsentiert den Start, ab welchem Index die Freunde geholt werden sollen und der Parameter \verb|-1| das Ende. In diesem Fall heißt \verb|-1|, dass alle Elemente aus der Liste geholt werden sollen. Die Daten werden im letzten Schritt mittels der Array \verb|map()| Funktion noch vernünftig aufbereitet um die Nutzung der Daten zu vereinfachen.

\subsubsection{parseFriendList}
\label{sec:parseFriendList}

\begin{lstlisting}[style=codeStyle, caption={Methode um alle Informationen eines Arrays von Freunden zu bekommen}, label={lst:parseFriendList}]
const parseFriendList = async (friendList) => {
    const parsedFriendList = [];
    for (let friend of friendList) {
        const parsedFriend = await getUserData(friend.username);
        const activeGames = {};
        for (let activeGame of JSON.parse(parsedFriend.activeGames)) {
            activeGames[activeGame] = await getGame(activeGame);
        }
        parsedFriendList.push({
            username: friend.username,
            userid: friend.userid,
            connected: parsedFriend.connected,
            activeGames: activeGames
        });
    }
    return parsedFriendList;
}
\end{lstlisting}

Die Methode \verb|parseFriendList| hat die Funktion alle Daten aller Freunde einer Freundesliste zu holen. Sie dient als Erweiterung der \verb|getFriends| Methode, falls mehr Daten nötig sind, als lediglich der Benutzername und die \verb|userid|. Dies ist beispielsweise für die Anzeige im Frontend der Fall (siehe Kapitel \ref{sec:Senden-der-Freunde}).

Mit einer for-Schleife wird das Array der Freunde durchlaufen und für jeden Spieler werden folgende Daten gesammelt:

\begin{itemize}
\item Online-Status \& aktive Partien: Aus dem Redis Eintrag \verb|user:username| wird mittels der \verb|getUserData| Methode alle Werte des \verb|user:username| Eintrags des Freundes geholt. Dazu zählen der online-Status und die roomIds der aktiven Partien
\item Daten der Aktiven Partien: Anschließend wird für jede aktive Partie dieses Freundes die Daten aus \verb|game:roomId| mittels der Funktion \verb|getGameData| abgerufen. Dies ist wichtig um im Frontend anzeigen lassen zu können, welche Farbe und gegen wen der Freund spielt.

\end{itemize}

Anschließend werden diese Daten in einem Objekt gesammelt und der neuen Freundesliste hinzugefügt, welche am Ende zurückgegeben wird.

\subsubsection{requestFriend und friendIsValid}
\label{sec:requestFriend}

\begin{lstlisting}[style=codeStyle, caption={requestFriend Methode um eine Freundschaftsanfrage in redis zu speichern}, label={lst:requestFriend}]
module.exports.requestFriend = async (username, userid, requestName) => {
    const requestedFriend = await friendIsValid(username, requestName);
    if (requestedFriend.errorMsg) {
        return {errorMsg: requestedFriend.errorMsg};
    }
    const currentFriendRequests = await redisClient.lrange(`friend_requests:${requestName}`, 0, -1);
    if (currentFriendRequests.includes([requestName, requestedFriend.userid].join(':'))) {
        return {errorMsg: "You've already sent a friend request to this user"};
    }
    await redisClient.lpush(`friend_requests:${requestName}`, [username, userid].join(":"));
    return {userid: requestedFriend.userid};
}
\end{lstlisting}

Die \verb|requestFriend| Methode wird beim Versenden einer Freundschaftsanfrage aufgerufen (siehe Kapitel \ref{sec:Freundschaftsanfrage-backend}), um zu überprüfen, ob eine Freundschaftsanfrage legal wäre und diese gegebenenfalls in Redis zu speichern.

Die Methode \verb|friendIsValid| überprüft, ob eine Freundschaft zulässig ist (siehe Codeausschnitt \ref{lst:friendIsValid}). Ist sie es nicht wird die entsprechende Fehlernachricht zurückgegeben. Um sicherzustellen, dass auch die Freundschaftsanfrage wirklich gültig ist, muss zusätzlich gewährleistet werden, dass zwischen den beiden Spielern keine ausstehenden Freundschaftsanfragen existieren (siehe Zeile 7 des Codeausschnitts \ref{lst:requestFriend}).

Ist dies nicht der Fall, kann die Freundschaftsanfrage der Liste unter dem Key \linebreak \verb|friend_requests:requestName| in der Form \verb|username:userid| hinzugefügt werden und die \verb|userid| des angefragten Freundes wird zurückgegeben, um an ihn die Freundschaftsanfrage zu senden (siehe Kapitel \ref{sec:Freundschaftsanfrage-backend}).

\begin{lstlisting}[style=codeStyle, caption={friendIsValid Methode um zu überprüfen, ob eine Freundschaft legal wäre}, label={lst:friendIsValid}]
const friendIsValid = async (username, requestName) => {
    if (requestName === username) {
        return {errorMsg: "You can not add yourself as a Friend"};
    }
    const friend = await getUserData(requestName);
    if (!Object.keys(friend).length) {
        return {errorMsg: "User doesn't exist"};
    }
    const currentFriendList = await redisClient.lrange(`friends:${username}`, 0, -1);
    if (currentFriendList.includes([requestName, friend.userid].join(':'))) {
        return {errorMsg: "You are already friends with that user"};
    }
    return friend;
}
\end{lstlisting}

Bei einer legalen Freundschaft muss gewährleistet sein, dass man nicht mit sich selbst befreundet sein kann (siehe Zeile 2 des Codeausschnitts \ref{lst:friendIsValid}), dass der angefragte Benutzer existiert (siehe Ziele 5 \& 6) und, dass die beiden Benutzer nicht bereits befreundet sind.

Die Überprüfung ob der Nutzer existiert, basiert darauf, dass falls er nicht existiert \verb|friend| aus einem leeren Objekt \verb|{}| besteht, was bedeutet, dass \linebreak \verb|Object.keys(friend).length| gleich 0 ist (siehe Zeile 6). Der \verb|!|-Ausdruck konvertiert diesen Wert zunächst in den booleschen Wert \verb|false| und negiert ihn anschließend, sodass der Ausdruck \verb|true| zurückgibt.

