
\chapter{Implementierung}
    \section{Frontend-Entwicklung}
    \subsection{Authentifizierung}
Die verschiedenen Art und Weisen und Abläufe der Authentifizierung wurde im Kapitel \ref{sec:Autehtifizierung Frontend} behandelt.
In diesem Kapitel werde ich näher auf die genaue Implementierung dieser Abläufe eingehen, erklären wie die Formik Formulare funktionieren und konkrete Code Ausschnitte vorstellen.
    \subsubsection{Erster Versuch der Authetifizierung mittels Cookie}
    \label{sec:Cookie-auth}
Im Code Ausschnitt \ref{lst:AccountContext} ist der Code der gesamten AccountContext Datei zu sehen, welche den \textit{UserContext} zur Verfügung stellt.

\begin{lstlisting}[style=codeStyle, caption={Die AccountContext.js-Datei}, label={lst:AccountContext}]
import React, {useEffect, useState, createContext} from "react";

export const AccountContext = createContext();

const UserContext = ({children}) => {
    const [user, setUser] = useState({loggedIn: null});

     /**
     * Set User with Cookie, if possible
     */
    useEffect(() => {
        fetch(`${process.env.REACT_APP_API_URL}/auth/login`, {
            credentials: "include",
        })
            .catch(err => {
                console.log(err);
                return;
            })
            .then(r => {
                if (!r || !r.ok || r.status >= 400) {
                    return;
                }
                return r.json();
            })
            .then(data => {
                setUser({ ...data});
            });
    }, []);
    return (
        <AccountContext.Provider value ={{user, setUser}}>
            {children}
        </AccountContext.Provider>
    );
}
export default UserContext;
\end{lstlisting}


In ihr wird der State \verb|user| mit \verb|{loggedIn: null}| initialisiert. Weshalb wir dies tun wird in Abschnitt //REF erläutert. Sobald die Komponente gerendert wurde, wird die Funktion der \verb|useEffect|-Hook ausgeführt. Das leere Dependency Array verursacht, dass sie nur dieses eine mal ausgeführt wird. Die Funktion schickt eine HTTP GET-Anfrage unter \verb|/auth/login| an den Server mit der Option, dass Credentials mitgesendet werden sollen. Dies stellt sicher, dass der Cookie mit dem JWT-Token an den Server gesendet wird und dort verifiziert werden kann. Der restliche Pfad ist als Umgebungsvariable gesetzt um den Pfad flexibel ändern zu können.

Gibt es einen Fehler oder eine ungültige Antwort wird der Vorgang abgebrochen, ansonsten wird der \verb|user| mit den erhaltenen Daten gesetzt.

Mögliche Optionen sind dabei:
\begin{itemize}
\item \verb|{loggedIn: false}|, falls man nicht authentifiziert werden konnte.
\item \verb|{loggedIn: true, username: Max}|, bei erfolgreichem Authentifizieren. (Max ist hier nur ein Beispiel als username)
\end{itemize}
Mehr Informationen benötigt der Benutzer aktuell nicht über sich selbst.

\subsubsection{Authentifizierung mittels \textit{SignUp}- oder \textit{Login}-Komponente}
Um sich mit Hilfe von den \textit{SignUp}- oder \textit{Login}-Komponenten anzumelden wird eine HTTP POST-Anfrage an den Server unter dem Pfad \verb|/auth/login| oder \verb|/auth/signup| gesendet.

Die Funktion zum Senden der Login-Daten an den Server befindet sich in Code Ausschnitt \ref{lst:submitLogin}.

\begin{lstlisting}[style=codeStyle, caption={Die Funktion zum Senden der Benutzerdaten an das Backend}, label={lst:submitLogin}]
    /**
     * Submit the form and send it to the server. Set either the user data or an error message based on the response.
     * @type {function({username, password}, function(boolean): void): void}
     */
    const submitLogin = useCallback((values, setSubmitting) => {
        fetch(`${process.env.REACT_APP_API_URL}/auth/login`, {
            method: "POST",
            credentials: "include",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(values)
        })
            .catch(err => {
                setLoginError("Please try again later");
                setSubmitting(false);
                return;
            })
            .then(res => {
                if (!res || !res.ok || res.status >= 400) {
                    setSubmitting(false);
                    setLoginError("Please try again later");
                    return;
                }
                return res.json();
            })
            .then(data => {
                if (!data.loggedIn) {
                    setLoginError(data.message);
                    setSubmitting(false);
                    return;
                }
                setUser({...data});
                setLoginError(null);
                navigate('/');
            });
    }, [setLoginError, setUser, navigate]);
\end{lstlisting}

Die Funktion zum Senden der Registrierungs-Daten sieht genau so aus, nur dass die Anfrage an einen anderen Pfad geht und es mehr Daten enthält, wie zum Beispiel die E-Mail.

Initialisiert wird die Funktion mittels der \textit{useCallback}-Hook um unnötige Neuerstellungen zu vermeiden.Der \glqq Content-Type\grqq{ }hilft dem Server zu erkennen um was für eine Art von Daten es sich handelt, während im Body die angegebenen Anmeldedaten als String verpackt werden. Falls der Server mit einem Fehler Antwortet, wird dieser in dem State \verb|loginError| erfasst. Ansonsten wird der Benutzerstatus gesetzt und es wird auf die \textit{Home}-Komponente navigiert.

Das Formular wird mittels Formik reaktiv und nutzt Yup Schemata zum überprüfen der eingegebenen Werte.

\begin{lstlisting}[style=codeStyle, caption={Ein Ausschnitt der \textit{Login}-Komponente mit Formik}, label={lst:Login_Formik}]
...
<Formik
    initialValues={{
        username: "",
        password: "",
    }}
    validationSchema={LoginSchema}
    validateOnChange={true}
    onSubmit={(values, { setSubmitting }) => {
        submitLogin(values, setSubmitting);
    }}
>
    {({ isValid, isSubmitting }) => (
        <Form style={{ width: "100%" }}>
        		...
            <Field name="password">
               {({ field, form }) => (
                  <FormControl isInvalid={form.errors.password && form.touched.password}>
                      <FormLabel htmlFor="password">Password</FormLabel>
                      <InputGroup>
                           <Input {...field} 
                           	id="password" 
                           	type={showPassword ? 'text' : 'password'} 
                           	autoComplete="current-password" />
                           <InputRightElement>
                               <IconButton
                                   icon={showPassword ? <ViewOffIcon /> : <ViewIcon />}
                                   onClick={handlePasswordClick}
                                   variant="ghost"
                                   _hover={{ bg: hover }}
                                   aria-label="Toggle password visibility"
                               />
                           </InputRightElement>
                       </InputGroup>
                       <FormErrorMessage>{form.errors.password}
                       </FormErrorMessage>
                   </FormControl>
               )}
            </Field>
            ...
            <Button
                type="submit"
                isDisabled={!isValid || isSubmitting}
                ...
            >
               Log In
            </Button>
\end{lstlisting}

In diesem Code Ausschnitt ist das von Formik verwaltete Formular der \textit{Login}-Komponente zu erkennen (die Komponente ist in Abbildung \ref{fig:Login} dargestellt). Als Schema für dieses Formular wird das Yup Schema \verb|LoginSchema| verwendet (siehe Code Ausschnitt \ref{lst:Yup-Login}) und es wird definiert, dass bei jeder neuen Änderung der Eingabefelder des Formulars, die Eingaben auf das Schema getestet werden sollen.

\verb|isValid| und \verb|isSubmitting| (Zeile 13) sind props, die man von Formik zur Verfügung gestellt bekommt und die angeben, ob die Eingabefelder mit dem Schema übereinstimmen und ob gerade noch auf die Antwort des Servers gewartet wird. Dies ist auch der Grund, warum wir \verb|setSubmitting| der \verb|submitLogin| Funktion übergeben. Wird noch auf die Antwort des Servers gewartet oder das Formular stimmt nicht mit dem Schema überein, wird der Button deaktiviert, sodass man ihn nicht mehr klicken kann zum Absenden.

Als Eingabefelder, gibt es  den Benutzernamen und das Passwort. Aus Demonstrationszwecken habe ich in den Code Ausschnitt \ref{lst:Login_Formik} nur das Passwort eingefügt.

Die Props \verb|field| und \verb|form| versorgen das Feld mit Informationen und Funktionen für das Feld und über das gesamte Formular. So wird in Zeile 21 das Input Feld mit dem \verb|field| prop verknüpft, welches Attribute wie die Funktion \verb|field.onChange| oder \verb|field.value| besitzt. \verb|form| wird genutzt um Beispielsweise wie in Zeile 35 ein Fehler beim Passwort anzuzeigen, falls dies nicht mit dem Schema übereinstimmt.

Gestaltet wird das Formular mit Komponenten von Chakra UI, welche viele hilfreiche Komponenten wie \verb|FormErrorMessage| oder \verb|IconButton| bereitstellt. Mit Attributen wie \verb|_hover| oder \verb|variant| können diese Komponenten noch weiter individualisiert werden.

Die \textit{Login}-Komponente besitzt den boolean State \verb|showPassword|, welcher angibt, ob das Passwort zu sehen sein soll oder nicht (Zeile 23). Bei einem Klick auf das Icon mit dem Auge wird die Funktion \verb|handlePasswordClick| ausgeführt, welche den \verb|showPassword| State negiert.

Die Formulierung von Schemata mittels Yup ist relativ simpel.

\begin{lstlisting}[style=codeStyle, caption={Yup Schma für das Anmelden}, label={lst:Yup-Login}]
const LoginSchema = Yup.object().shape({
    username: Yup.string()
        .min(3, 'Username has to be at least 3 characters long')
        .max(20, 'Username cannot be longer than 20 characters')
        .test('not_guest', 'Username cannot start with "guest"', (value) => {
            return !value.startsWith('guest');
        })
        .required('Username is a required field'),
    password: Yup.string()
        .min(8, 'Password has to be at least 8 characters long')
        .minLowercase(1, 'At least one character hat to be in lower case')
        .minUppercase(1, 'At least one character has to be in upper case')
        .minNumbers(1, 'At least on character has to be a number')
        .minSymbols(1, 'At least one character has to be a symbol')
        .minRepeating(3, 'It is only allowed to have at most 3 repeating characters')
        .required('Password is a required field'),
});
\end{lstlisting}

In diesem Beispiel ist das \verb|LoginSchema| zu sehen, welches für die Validierung der Eingabefelder im Anmeldeformular aus Code Ausschnitt \ref{lst:Login_Formik} verwendet wird. Yup ermöglicht es bestimmte Restriktionen an Eingabefelder zu stellen und dabei direkt die Fehlernachricht zu definieren, falls diese Restriktion nicht erfüllt ist. Selbstverständlich sind die Restriktionen für das Registrieren die gleichen, wobei das Registrierungsformular noch ein paar weitere Felder hat.

Ich verwende übliche Restriktionen an Benutzernamen und Passwörter, sodass das Passwort mindestens eine Nummer, ein Symbol, einen Großbuchstaben, ... beinhalten muss. Eine Sonderheit ist, dass der Benutzername nicht mit \glqq guest\grqq{ }beginnen darf, da ich unangemeldete Benutzer bei Schachpartien einen solchen Benutzernamen gebe. 


\subsubsection{Socket.io Verbindungsaufbau}
Immer sobald sich der Benutzerzustand ändert wird eine Socket.io Verbindung hergestellt und den anderen Komponenten zur Verfügung gestellt. Dies hat den Nutzen, dass beim Verbindungsaufbau immer auch die socket auf dem Server authentifiziert werden muss.

Dafür wird die \textit{SocketContext}-Komponente verwendet:

\begin{lstlisting}[style=codeStyle, caption={Die Datei \textit{SocketContext.js}}, label={lst:SocketContext}]
import {io} from "socket.io-client";
import React, {useContext, useEffect, useState, createContext} from "react";
import {AccountContext} from "./AccountContext.js";

export const SocketContext = createContext();

function SocketConnectionContext({children}) {
    const [socket, setSocket] = useState(null);
    const {user} = useContext(AccountContext);

    /**
     * New socket connection every time the user changes.
     */
    useEffect(() => {
        if(user.loggedIn !== null) {
            setSocket(new io(process.env.REACT_APP_SOCKET_URL, {
                withCredentials: true
            }));
        }
    }, [user]);

    return (
        <SocketContext.Provider value={{socket}}>
            {children}
        </SocketContext.Provider>
    );
}

export default SocketConnectionContext;
\end{lstlisting}

Bei der Verbindung wird darauf geachtet, dass die Credentials mitgesendet werden, also beispielsweise auch Cookies. Des weiteren wird erst eine Verbindung aufgebaut, sobald die Antwort des Servers auf die Authentifizierungs-Anfrage mittels Cookie (siehe Abschnitt \ref{sec:Cookie-auth}) empfangen wurde und dadurch das \verb|user.loggedIn| Attribut nicht mehr \verb|null| ist. Dies dient dazu einen unnötigen Verbindungsaufbau zu unterlassen, da nach der Antwort des Servers ohnehin eine neue Verbindung aufgebaut werden würde.

Erst sobald die erste Authentifizierung stattgefunden hat und eine Socket.io Verbindung hergestellt wurde, werden die verschiedenen Elemente und Routen in der \verb|Views|-Komponente definiert. So lange wird ein Lade-Bildschirm gezeigt (siehe Code Ausschnitt \ref{lst:Views-user-socket}).

\begin{lstlisting}[style=codeStyle, caption={Ausschnitt der \textit{Views}-Komponente}, label={lst:Views-user-socket}]
		   ...
        {user.loggedIn === null || socket === null ?
                <Flex align="center" justify="center" direction="column" height="80vh">
                    <Heading as='h2' size='lg'>Loading...</Heading>
                    <Spinner size='xl' color="purple.500" marginTop="4"/>
                </Flex>

                :
                <>
                    <Navbar/>
                    ...
\end{lstlisting}


    \section{Backend-Entwicklung}
    \subsection{Authentifizierung}
Die Vorgehensweise im Backend bei der Authentifizierung des Benutzers ist im Kapitel \ref{sec:Authentifizierung Backend} geschildert. In diesem Kapitel werde ich Code Beispiele vorstellen und erläutern.

\subsubsection{Routing-Middlewares}
Der Code Ausschnitt \ref{lst:routing-Middlewares} zeigt die Reihenfolge der Middlewares bei den Anmelde- und Registrierungsanfragen des Frontends.
\begin{lstlisting}[style=codeStyle, caption={Ausschnitt aus index.js und die Datei authRouter.js}, label={lst:routing-Middlewares}]
//index.js
...
app.use("/auth", authRouter);
...

//authRouter.js
const express = require('express');
const router = express.Router();
... //import der Middlewares

router.use(rateLimiter(60, 10));

router.route('/login').get(handleLogin).post(validateLogin, attemptLogin);

router.post('/signup', validateSignUp, attemptSignUp);

router.get('/logout', handleLogout);

module.exports = router;
\end{lstlisting}

Für jede Anfrage auf den Pfad \verb|/auth| wird die Middleware \verb|rateLimiter| verwendet. Dieser achtet darauf, dass nicht zu viele Anfragen einer IP Adresse gesendet werden. 

\begin{lstlisting}[style=codeStyle, caption={Die rateLimiter Middleware}, label={lst:rateLimiter}]
const redisClient = require("../redis/redis.js");
/**
 * Rate limiter middleware that limits the number of requests from a given IP address within a specified time window.
 * @param limitAmount - The maximum number of requests allowed within the time window.
 * @returns {function(*, *, *): Promise<void>} - Middleware function that either sends an error response if the limit is exceeded or calls the next middleware or route handler.
 */
module.exports.rateLimiter = (secondsLimit, limitAmount) => async (req, res, next) => {
    const ip = req.connection.remoteAddress;
    [response] = await redisClient
        .multi()
        .incr(ip)
        .expire(ip, secondsLimit)
        .exec();
    if (response[1] > limitAmount) {
        res.json({
            loggedIn: false,
            message: "Slow down!! Try again in a minute.",
        });
        res.sendStatus(429);
    }
    else next();
};
\end{lstlisting}

Der \verb|rateLimiter| nimmt die Argumente secondsLimit als Zeitfenster und limitAmount als Anfragelimit an und definiert mit Hilfe von ihnen die Middleware. Dafür nutzt er Redis und setzt mit der IP-Adresse als Key die Zahl der Anfragen als Value. Dieser Eintrag wird nach Ablauf des Zeitfensters gelöscht und falls das Anfragelimit innerhalb dieses Zeitfensters überschritten wurde, wird eine Fehlermeldung mit dem Statuscode 429 gesendet, der für \glqq Too Many Requests\grqq{ }steht\footnote{Quelle: \url{https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429} am 05. April 2023}. Andernfalls wird die nächste Middleware aufgerufen.

In unserer Anwendung legen wir fest, dass 10 Anfragen innerhalb von 60 Sekunden gesendet werden dürfen.

Für die erste Authentifizierung im \textit{UserContext} (siehe Abschnitt \ref{sec:Cookie-auth}) wird die Middleware \verb|handleLogin| verwendet.

\begin{lstlisting}[style=codeStyle, caption={Die handleLogin Middleware zum Authentifizieren mit Cookie}, label={lst:handleLogin}]
const getJwtFromCookie = req => {
    return req.headers["cookie"] && cookie.parse(req.headers["cookie"])["jwt"];
};

module.exports.handleLogin = (req, res) => {
    const token = getJwtFromCookie(req);
    if(!token) {
        res.json({loggedIn: false});
    } else {
        jwt.verify(token, process.env.JWT_SECRET, (err, decodedPayload) => {
            if (err) {
                res.json({loggedIn: false});
            } else {
                res.json({loggedIn: true, username: decodedPayload.username});
            }
        });
    }
};
\end{lstlisting}

Diese Middleware ließt gegebenenfalls den Cookie mit dem JWT-Token und antwortet entsprechend ob er ihn erfolgreich dekodieren konnte oder nicht.

Bei den POST Anfragen des Frontends, über die das ausgefüllte Anmelde-, beziehungsweise Registrierungsformular gesendet wird, wird vor der Auswertung mit den Middlewares \verb|validateLogin| oder \verb|validateSignUp| überprüft, ob das Formular auch dem entsprechenden Yup Schema übereinstimmt. Anschließend wird mit \verb|attemptLogin| oder \verb|attemptSignUp| versucht den Benutzern anzumelden oder zu registrieren.

\begin{lstlisting}[style=codeStyle, caption={Die attemptLogin Middleware zum Anmelden}, label={lst:attemptLogin}]
/**
 * Attempts to log in the user by checking the provided credentials against the database.
 * If the credentials match, creates a JWT token and sets it as a cookie in the response.
 * @param req - The incoming request object containing the user's login information.
 * @param res - The outgoing response object.
 * @returns {Promise<void>} - The Middleware
 */
module.exports.attemptLogin = async (req, res) => {
    const potentialLogin = await query(
        "SELECT id, username, password, userid FROM users u WHERE u.username=$1",
        [req.body.username]
    );
    if (potentialLogin.rowCount > 0) {
        const isSamePassword = await bcrypt.compare(
            req.body.password,
            potentialLogin.rows[0].password
        );
        if (isSamePassword) {
            const user = {
                username: req.body.username,
                userid: potentialLogin.rows[0].userid,
            }
            jwt.sign(
                user,
                process.env.JWT_SECRET,
                {expiresIn: "24h"},
                (err,token) => {
                if(err) {
                    res.json({loggedIn: false, message: "Something went wrong, try again later"});
                } else {
                    const jwtCookie = cookie.serialize("jwt", token, {
                        httpOnly: true,
                        secure: process.env.NODE_ENV === "production", // Secure flag only in production
                        maxAge: 24 * 60 * 60, // 24 hours
                        sameSite: "lax",
                        path: "/"
                    });
                    res.setHeader("Set-Cookie", jwtCookie);
                    res.json({loggedIn: true,  username: user.username});
                }
            }
            );
        } else {
            res.json({loggedIn: false, message: "Wrong username or password!"});
        }
    } else {
        res.json({loggedIn: false, message: "Wrong username or password!"});
    }
};
\end{lstlisting}

Die Middleware \verb|attemptLogin| überprüft zunächst, ob ein Benutzer mit diesem Benutzernamen existiert und mittels bcrypt ob die Passwörter übereinstimmen. Ist eines davon nicht der Fall wird das Frontend darüber benachrichtigt. Ansonsten wird ein 24 Stunden haltbarer JWT-Token mit dem Benutzernamen und der \verb|userid| generiert und in einen Cookie mit dem Key \glqq jwt\grqq{ }gesetzt, welcher ebenfalls 24 Stunden gültig ist. Wichtig dabei ist, dass das Attribut \verb|httpOnly| auf \verb|true| gesetzt wird, um zu verhindern, dass Client seitiger Code auf den Cookie zugreifen könnte. Anschließend wird dem Frontend noch mit dem JSON Objekt geantwortet (siehe Zeile 39).

Beim Registrieren wird ebenfalls bei Erfolg der Cookie mit dem JWT-Token gesetzt, jedoch sind die Anforderungen natürlich andere. Es wird überprüft, ob bereits ein Account mit dem Benutzernamen oder der E-Mail existiert und falls ja wird dem Frontend entsprechend geantwortet. Anschließend wird die \verb|userid| erstellt, das Passwort mit bcrypt verschlüsselt, der Tupel in der Datenbank gespeichert und der Cookie mit dem JWT-Token erstellt.

\subsubsection{Abmelden}
Da das Abmelden auch gewissermaßen zum Authentifizierungsprozess gehört, wird hier kurz beschrieben, was im Backend dabei passiert.

\begin{lstlisting}[style=codeStyle, caption={Middleware zum Abmelden}, label={lst:handleLogout}]
/**
 * Handles user logout by clearing the JWT cookie.
 * @param req - The request object.
 * @param res- The response object.
 */
module.exports.handleLogout = (req, res) => {
    res.setHeader(
        "Set-Cookie",
        cookie.serialize("jwt", "", {
            httpOnly: true,
            secure: process.env.NODE_ENV === "production",
            maxAge: -1,
            sameSite: "lax",
            path: "/"
        })
    );
    res.sendStatus(204);
}
\end{lstlisting}

Eine Anfrage zum Abmelden wird auf den Pfad \verb|auth/logout| gestellt unter der die Middleware aus Code Ausschnitt \ref{lst:handleLogout} durchlaufen wird. In dieser wird ein abgelaufener \glqq jwt\grqq  -Cookie gesetzt, der bewirkt, dass der bisherige \glqq jwt\grqq -Cookie gelöscht wird. Dann wird dem Frontend mit dem Code 204 geantwortet, welcher aussagt, dass die Anfrage erfolgreich bearbeitet wurde, jedoch keine Daten mit der Antwort gesendet werden\footnote{Quelle \url{https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204} am 05. Mai 2023}.

\subsubsection{Socket.io Authentifizierung}
