
\chapter{Implementierung}
    \section{Frontend-Entwicklung}
    \subsection{Authentifizierung}
    \label{sec:Auth-Impl-Front}
Die verschiedenen Art und Weisen und Abläufe der Authentifizierung wurde im Kapitel \ref{sec:Autehtifizierung Frontend} behandelt.
In diesem Kapitel werde ich näher auf die genaue Implementierung dieser Abläufe eingehen, erklären wie die Formik Formulare funktionieren und konkrete Code Ausschnitte vorstellen.
    \subsubsection{Erster Versuch der Authetifizierung mittels Cookie}
    \label{sec:Cookie-auth}
Im Code Ausschnitt \ref{lst:AccountContext} ist der Code der gesamten AccountContext Datei zu sehen, welche den \textit{UserContext} zur Verfügung stellt.

\begin{lstlisting}[style=codeStyle, caption={Die AccountContext.js-Datei}, label={lst:AccountContext}]
import React, {useEffect, useState, createContext} from "react";

export const AccountContext = createContext();

const UserContext = ({children}) => {
    const [user, setUser] = useState({loggedIn: null});

     /**
     * Set User with Cookie, if possible
     */
    useEffect(() => {
        fetch(`${process.env.REACT_APP_API_URL}/auth/login`, {
            credentials: "include",
        })
            .catch(err => {
                console.log(err);
                return;
            })
            .then(r => {
                if (!r || !r.ok || r.status >= 400) {
                    return;
                }
                return r.json();
            })
            .then(data => {
                setUser({ ...data});
            });
    }, []);
    return (
        <AccountContext.Provider value ={{user, setUser}}>
            {children}
        </AccountContext.Provider>
    );
}
export default UserContext;
\end{lstlisting}


In ihr wird der State \verb|user| mit \verb|{loggedIn: null}| initialisiert. Weshalb wir dies tun wird durch den Code Ausschnitt \ref{lst:Views-user-socket} und dessen Erklärung in Abschnitt \ref{sec:socket-Verbindung} ersichtlich. Sobald die Komponente gerendert wurde, wird die Funktion der \verb|useEffect|-Hook ausgeführt. Das leere Dependency Array verursacht, dass sie nur dieses eine Mal beim starten der Anwendung ausgeführt wird. Die Funktion schickt eine HTTP GET-Anfrage unter \verb|/auth/login| an den Server mit der Option, dass Credentials mitgesendet werden sollen. Dies stellt sicher, dass der Cookie mit dem JWT-Token an den Server gesendet wird und dort verifiziert werden kann. Der restliche Pfad ist als Umgebungsvariable gesetzt um den Pfad flexibel ändern zu können.

Gibt es einen Fehler oder eine ungültige Antwort wird der Vorgang abgebrochen, ansonsten wird der \verb|user| mit den erhaltenen Daten gesetzt.

Mögliche Optionen sind dabei:
\begin{itemize}
\item \verb|{loggedIn: false}|, falls man nicht authentifiziert werden konnte.
\item \verb|{loggedIn: true, username: Max}|, bei erfolgreichem Authentifizieren. (Max ist hier nur ein Beispiel als username)
\end{itemize}
Mehr Informationen benötigt der Benutzer aktuell nicht über sich selbst.

\subsubsection{Authentifizierung mittels \textit{SignUp}- oder \textit{Login}-Komponente}
Um sich mit Hilfe von den \textit{SignUp}- oder \textit{Login}-Komponenten anzumelden wird eine HTTP POST-Anfrage an den Server unter dem Pfad \verb|/auth/login| oder \verb|/auth/signup| gesendet.

Die Funktion zum Senden der Login-Daten an den Server befindet sich in Code Ausschnitt \ref{lst:submitLogin}.

\begin{lstlisting}[style=codeStyle, caption={Die Funktion zum Senden der Benutzerdaten an das Backend}, label={lst:submitLogin}]
    /**
     * Submit the form and send it to the server. Set either the user data or an error message based on the response.
     * @type {function({username, password}, function(boolean): void): void}
     */
    const submitLogin = useCallback((values, setSubmitting) => {
        fetch(`${process.env.REACT_APP_API_URL}/auth/login`, {
            method: "POST",
            credentials: "include",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify(values)
        })
            .catch(err => {
                setLoginError("Please try again later");
                setSubmitting(false);
                return;
            })
            .then(res => {
                if (!res || !res.ok || res.status >= 400) {
                    setSubmitting(false);
                    setLoginError("Please try again later");
                    return;
                }
                return res.json();
            })
            .then(data => {
                if (!data.loggedIn) {
                    setLoginError(data.message);
                    setSubmitting(false);
                    return;
                }
                setUser({...data});
                setLoginError(null);
                navigate('/');
            });
    }, [setLoginError, setUser, navigate]);
\end{lstlisting}

Die Funktion zum Senden der Registrierungs-Daten sieht genau so aus, nur dass die Anfrage an einen anderen Pfad geht und es mehr Daten enthält, wie zum Beispiel die E-Mail.

Initialisiert wird die Funktion mittels der \textit{useCallback}-Hook um unnötige Neuerstellungen zu vermeiden.Der \glqq Content-Type\grqq{ }hilft dem Server zu erkennen um was für eine Art von Daten es sich handelt, während im Body die angegebenen Anmeldedaten als String verpackt werden. Falls der Server mit einem Fehler Antwortet, wird dieser in dem State \verb|loginError| erfasst. Ansonsten wird der Benutzerstatus gesetzt und es wird auf die \textit{Home}-Komponente navigiert.

Das Formular wird mittels Formik reaktiv und nutzt Yup Schemata zum überprüfen der eingegebenen Werte.

\begin{lstlisting}[style=codeStyle, caption={Ein Ausschnitt der \textit{Login}-Komponente mit Formik}, label={lst:Login_Formik}]
...
<Formik
    initialValues={{
        username: "",
        password: "",
    }}
    validationSchema={LoginSchema}
    validateOnChange={true}
    onSubmit={(values, { setSubmitting }) => {
        submitLogin(values, setSubmitting);
    }}
>
    {({ isValid, isSubmitting }) => (
        <Form style={{ width: "100%" }}>
        		...
            <Field name="password">
               {({ field, form }) => (
                  <FormControl isInvalid={form.errors.password && form.touched.password}>
                      <FormLabel htmlFor="password">Password</FormLabel>
                      <InputGroup>
                           <Input {...field} 
                           	id="password" 
                           	type={showPassword ? 'text' : 'password'} 
                           	autoComplete="current-password" />
                           <InputRightElement>
                               <IconButton
                                   icon={showPassword ? <ViewOffIcon /> : <ViewIcon />}
                                   onClick={handlePasswordClick}
                                   variant="ghost"
                                   _hover={{ bg: hover }}
                                   aria-label="Toggle password visibility"
                               />
                           </InputRightElement>
                       </InputGroup>
                       <FormErrorMessage>{form.errors.password}
                       </FormErrorMessage>
                   </FormControl>
               )}
            </Field>
            ...
            <Button
                type="submit"
                isDisabled={!isValid || isSubmitting}
                ...
            >
               Log In
            </Button>
\end{lstlisting}

In diesem Code Ausschnitt ist das von Formik verwaltete Formular der \textit{Login}-Komponente zu erkennen (die Komponente ist in Abbildung \ref{fig:Login} dargestellt). Als Schema für dieses Formular wird das Yup Schema \verb|LoginSchema| verwendet (siehe Code Ausschnitt \ref{lst:Yup-Login}) und es wird definiert, dass bei jeder neuen Änderung der Eingabefelder des Formulars, die Eingaben auf das Schema getestet werden sollen.

\verb|isValid| und \verb|isSubmitting| (Zeile 13) sind props, die man von Formik zur Verfügung gestellt bekommt und die angeben, ob die Eingabefelder mit dem Schema übereinstimmen und ob gerade noch auf die Antwort des Servers gewartet wird. Dies ist auch der Grund, warum wir \verb|setSubmitting| der \verb|submitLogin| Funktion übergeben. Wird noch auf die Antwort des Servers gewartet oder das Formular stimmt nicht mit dem Schema überein, wird der Button deaktiviert, sodass man ihn nicht mehr klicken kann zum Absenden.

Als Eingabefelder, gibt es  den Benutzernamen und das Passwort. Aus Demonstrationszwecken habe ich in den Code Ausschnitt \ref{lst:Login_Formik} nur das Passwort eingefügt.

Die Props \verb|field| und \verb|form| versorgen das Feld mit Informationen und Funktionen für das Feld und über das gesamte Formular. So wird in Zeile 21 das Input Feld mit dem \verb|field| prop verknüpft, welches Attribute wie die Funktion \verb|field.onChange| oder \verb|field.value| besitzt. \verb|form| wird genutzt um Beispielsweise wie in Zeile 35 ein Fehler beim Passwort anzuzeigen, falls dies nicht mit dem Schema übereinstimmt.

Gestaltet wird das Formular mit Komponenten von Chakra UI, welche viele hilfreiche Komponenten wie \verb|FormErrorMessage| oder \verb|IconButton| bereitstellt. Mit Attributen wie \verb|_hover| oder \verb|variant| können diese Komponenten noch weiter individualisiert werden.

Die \textit{Login}-Komponente besitzt den boolean State \verb|showPassword|, welcher angibt, ob das Passwort zu sehen sein soll oder nicht (Zeile 23). Bei einem Klick auf das Icon mit dem Auge wird die Funktion \verb|handlePasswordClick| ausgeführt, welche den \verb|showPassword| State negiert.

Die Formulierung von Schemata mittels Yup ist relativ simpel.

\begin{lstlisting}[style=codeStyle, caption={Yup Schma für das Anmelden}, label={lst:Yup-Login}]
const LoginSchema = Yup.object().shape({
    username: Yup.string()
        .min(3, 'Username has to be at least 3 characters long')
        .max(20, 'Username cannot be longer than 20 characters')
        .test('not_guest', 'Username cannot start with "guest"', (value) => {
            return !value.startsWith('guest');
        })
        .required('Username is a required field'),
    password: Yup.string()
        .min(8, 'Password has to be at least 8 characters long')
        .minLowercase(1, 'At least one character hat to be in lower case')
        .minUppercase(1, 'At least one character has to be in upper case')
        .minNumbers(1, 'At least on character has to be a number')
        .minSymbols(1, 'At least one character has to be a symbol')
        .minRepeating(3, 'It is only allowed to have at most 3 repeating characters')
        .required('Password is a required field'),
});
\end{lstlisting}

In diesem Beispiel ist das \verb|LoginSchema| zu sehen, welches für die Validierung der Eingabefelder im Anmeldeformular aus Code Ausschnitt \ref{lst:Login_Formik} verwendet wird. Yup ermöglicht es bestimmte Restriktionen an Eingabefelder zu stellen und dabei direkt die Fehlernachricht zu definieren, falls diese Restriktion nicht erfüllt ist. Selbstverständlich sind die Restriktionen für das Registrieren die gleichen, wobei das Registrierungsformular noch ein paar weitere Felder hat.

Ich verwende übliche Restriktionen an Benutzernamen und Passwörter, sodass das Passwort mindestens eine Nummer, ein Symbol, einen Großbuchstaben, ... beinhalten muss. Eine Sonderheit ist, dass der Benutzername nicht mit \glqq guest\grqq{ }beginnen darf, da ich unangemeldete Benutzer bei Schachpartien einen solchen Benutzernamen gebe. 


\subsubsection{Socket.io Verbindungsaufbau}
\label{sec:socket-Verbindung}
Immer sobald sich der Benutzerzustand ändert wird eine Socket.io Verbindung hergestellt und den anderen Komponenten zur Verfügung gestellt. Dies hat den Nutzen, dass beim Verbindungsaufbau immer auch die socket auf dem Server authentifiziert werden muss.

Dafür wird die \textit{SocketContext}-Komponente verwendet:

\begin{lstlisting}[style=codeStyle, caption={Die Datei \textit{SocketContext.js}}, label={lst:SocketContext}]
import {io} from "socket.io-client";
import React, {useContext, useEffect, useState, createContext} from "react";
import {AccountContext} from "./AccountContext.js";

export const SocketContext = createContext();

function SocketConnectionContext({children}) {
    const [socket, setSocket] = useState(null);
    const {user} = useContext(AccountContext);

    /**
     * New socket connection every time the user changes.
     */
    useEffect(() => {
        if(user.loggedIn !== null) {
            setSocket(new io(process.env.REACT_APP_SOCKET_URL, {
                withCredentials: true
            }));
        }
    }, [user]);

    return (
        <SocketContext.Provider value={{socket}}>
            {children}
        </SocketContext.Provider>
    );
}

export default SocketConnectionContext;
\end{lstlisting}

Bei der Verbindung wird darauf geachtet, dass die Credentials mitgesendet werden, also beispielsweise auch Cookies. Des weiteren wird erst eine Verbindung aufgebaut, sobald die Antwort des Servers auf die Authentifizierungs-Anfrage mittels Cookie (siehe Abschnitt \ref{sec:Cookie-auth}) empfangen wurde und dadurch das \verb|user.loggedIn| Attribut nicht mehr \verb|null| ist. Dies dient dazu einen unnötigen Verbindungsaufbau zu unterlassen, da nach der Antwort des Servers ohnehin eine neue Verbindung aufgebaut werden würde.

Erst sobald die erste Authentifizierung stattgefunden hat und eine Socket.io Verbindung hergestellt wurde, werden die verschiedenen Elemente und Routen in der \verb|Views|-Komponente definiert. So lange wird ein Lade-Bildschirm gezeigt (siehe Code Ausschnitt \ref{lst:Views-user-socket}).

\begin{lstlisting}[style=codeStyle, caption={Ausschnitt der \textit{Views}-Komponente}, label={lst:Views-user-socket}]
		   ...
        {user.loggedIn === null || socket === null ?
                <Flex align="center" justify="center" direction="column" height="80vh">
                    <Heading as='h2' size='lg'>Loading...</Heading>
                    <Spinner size='xl' color="purple.500" marginTop="4"/>
                </Flex>

                :
                <>
                    <Navbar/>
                    ...
\end{lstlisting}


    \section{Backend-Entwicklung}
    \subsection{Authentifizierung}
Die Vorgehensweise im Backend bei der Authentifizierung des Benutzers ist im Kapitel \ref{sec:Authentifizierung Backend} geschildert. In diesem Kapitel werde ich Code Beispiele vorstellen und erläutern.

\subsubsection{Routing-Middlewares}
Der Code Ausschnitt \ref{lst:routing-Middlewares} zeigt die Reihenfolge der Middlewares bei den Anmelde- und Registrierungsanfragen des Frontends.
\begin{lstlisting}[style=codeStyle, caption={Ausschnitt aus index.js und die Datei authRouter.js}, label={lst:routing-Middlewares}]
//index.js
...
app.use("/auth", authRouter);
...

//authRouter.js
const express = require('express');
const router = express.Router();
... //import der Middlewares

router.use(rateLimiter(60, 10));

router.route('/login').get(handleLogin).post(validateLogin, attemptLogin);

router.post('/signup', validateSignUp, attemptSignUp);

router.get('/logout', handleLogout);

module.exports = router;
\end{lstlisting}

Für jede Anfrage auf den Pfad \verb|/auth| wird die Middleware \verb|rateLimiter| verwendet. Dieser achtet darauf, dass nicht zu viele Anfragen einer IP Adresse gesendet werden. 

\begin{lstlisting}[style=codeStyle, caption={Die rateLimiter Middleware}, label={lst:rateLimiter}]
const redisClient = require("../redis/redis.js");
/**
 * Rate limiter middleware that limits the number of requests from a given IP address within a specified time window.
 * @param limitAmount - The maximum number of requests allowed within the time window.
 * @returns {function(*, *, *): Promise<void>} - Middleware function that either sends an error response if the limit is exceeded or calls the next middleware or route handler.
 */
module.exports.rateLimiter = (secondsLimit, limitAmount) => async (req, res, next) => {
    const ip = req.connection.remoteAddress;
    [response] = await redisClient
        .multi()
        .incr(ip)
        .expire(ip, secondsLimit)
        .exec();
    if (response[1] > limitAmount) {
        res.json({
            loggedIn: false,
            message: "Slow down!! Try again in a minute.",
        });
        res.sendStatus(429);
    }
    else next();
};
\end{lstlisting}

Der \verb|rateLimiter| nimmt die Argumente secondsLimit als Zeitfenster und limitAmount als Anfragelimit an und definiert mit Hilfe von ihnen die Middleware. Dafür nutzt er Redis und setzt mit der IP-Adresse als Key die Zahl der Anfragen als Value. Dieser Eintrag wird nach Ablauf des Zeitfensters gelöscht und falls das Anfragelimit innerhalb dieses Zeitfensters überschritten wurde, wird eine Fehlermeldung mit dem Statuscode 429 gesendet, der für \glqq Too Many Requests\grqq{ }steht\footnote{Quelle: \url{https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429} am 05. April 2023}. Andernfalls wird die nächste Middleware aufgerufen.

In unserer Anwendung legen wir fest, dass 10 Anfragen innerhalb von 60 Sekunden gesendet werden dürfen.

Für die erste Authentifizierung im \textit{UserContext} (siehe Abschnitt \ref{sec:Cookie-auth}) wird die Middleware \verb|handleLogin| verwendet.

\begin{lstlisting}[style=codeStyle, caption={Die handleLogin Middleware zum Authentifizieren mit Cookie}, label={lst:handleLogin}]
const getJwtFromCookie = req => {
    return req.headers["cookie"] && cookie.parse(req.headers["cookie"])["jwt"];
};

module.exports.handleLogin = (req, res) => {
    const token = getJwtFromCookie(req);
    if(!token) {
        res.json({loggedIn: false});
    } else {
        jwt.verify(token, process.env.JWT_SECRET, (err, decodedPayload) => {
            if (err) {
                res.json({loggedIn: false});
            } else {
                res.json({loggedIn: true, username: decodedPayload.username});
            }
        });
    }
};
\end{lstlisting}

Diese Middleware ließt gegebenenfalls den Cookie mit dem JWT-Token und antwortet entsprechend ob er ihn erfolgreich dekodieren konnte oder nicht.

Bei den POST Anfragen des Frontends, über die das ausgefüllte Anmelde-, beziehungsweise Registrierungsformular gesendet wird, wird vor der Auswertung mit den Middlewares \verb|validateLogin| oder \verb|validateSignUp| überprüft, ob das Formular auch dem entsprechenden Yup Schema übereinstimmt. Anschließend wird mit \verb|attemptLogin| oder \verb|attemptSignUp| versucht den Benutzern anzumelden oder zu registrieren.

\begin{lstlisting}[style=codeStyle, caption={Die attemptLogin Middleware zum Anmelden}, label={lst:attemptLogin}]
/**
 * Attempts to log in the user by checking the provided credentials against the database.
 * If the credentials match, creates a JWT token and sets it as a cookie in the response.
 * @param req - The incoming request object containing the user's login information.
 * @param res - The outgoing response object.
 * @returns {Promise<void>} - The Middleware
 */
module.exports.attemptLogin = async (req, res) => {
    const potentialLogin = await query(
        "SELECT id, username, password, userid FROM users u WHERE u.username=$1",
        [req.body.username]
    );
    if (potentialLogin.rowCount > 0) {
        const isSamePassword = await bcrypt.compare(
            req.body.password,
            potentialLogin.rows[0].password
        );
        if (isSamePassword) {
            const user = {
                username: req.body.username,
                userid: potentialLogin.rows[0].userid,
            }
            jwt.sign(
                user,
                process.env.JWT_SECRET,
                {expiresIn: "24h"},
                (err,token) => {
                if(err) {
                    res.json({loggedIn: false, message: "Something went wrong, try again later"});
                } else {
                    const jwtCookie = cookie.serialize("jwt", token, {
                        httpOnly: true,
                        secure: process.env.NODE_ENV === "production", // Secure flag only in production
                        maxAge: 24 * 60 * 60, // 24 hours
                        sameSite: "lax",
                        path: "/"
                    });
                    res.setHeader("Set-Cookie", jwtCookie);
                    res.json({loggedIn: true,  username: user.username});
                }
            }
            );
        } else {
            res.json({loggedIn: false, message: "Wrong username or password!"});
        }
    } else {
        res.json({loggedIn: false, message: "Wrong username or password!"});
    }
};
\end{lstlisting}

Die Middleware \verb|attemptLogin| überprüft zunächst, ob ein Benutzer mit diesem Benutzernamen existiert und mittels bcrypt ob die Passwörter übereinstimmen. Ist eines davon nicht der Fall wird das Frontend darüber benachrichtigt. Ansonsten wird ein 24 Stunden haltbarer JWT-Token mit dem Benutzernamen und der \verb|userid| generiert und in einen Cookie mit dem Key \glqq jwt\grqq{ }gesetzt, welcher ebenfalls 24 Stunden gültig ist. Der JWT-Token beinhaltet die \verb|userid|, da die Socket Verbindung diese Information beim authentifizieren benötigt (siehe Abschnitt \ref{sec:Backend-Socket}).  Wichtig dabei ist, dass das Attribut \verb|httpOnly| auf \verb|true| gesetzt wird, um zu verhindern, dass Client seitiger Code auf den Cookie zugreifen könnte. Anschließend wird dem Frontend noch mit dem JSON Objekt geantwortet (siehe Zeile 39).

Beim Registrieren wird ebenfalls bei Erfolg der Cookie mit dem JWT-Token gesetzt, jedoch sind die Anforderungen natürlich andere. Es wird überprüft, ob bereits ein Account mit dem Benutzernamen oder der E-Mail existiert und falls ja wird dem Frontend entsprechend geantwortet. Anschließend wird die \verb|userid| erstellt, das Passwort mit bcrypt verschlüsselt, der Tupel in der Datenbank gespeichert und der Cookie mit dem JWT-Token erstellt.

\subsubsection{Abmelden}
Da das Abmelden auch gewissermaßen zum Authentifizierungsprozess gehört, wird hier kurz beschrieben, was im Backend dabei passiert.

\begin{lstlisting}[style=codeStyle, caption={Middleware zum Abmelden}, label={lst:handleLogout}]
/**
 * Handles user logout by clearing the JWT cookie.
 * @param req - The request object.
 * @param res- The response object.
 */
module.exports.handleLogout = (req, res) => {
    res.setHeader(
        "Set-Cookie",
        cookie.serialize("jwt", "", {
            httpOnly: true,
            secure: process.env.NODE_ENV === "production",
            maxAge: -1,
            sameSite: "lax",
            path: "/"
        })
    );
    res.sendStatus(204);
}
\end{lstlisting}

Eine Anfrage zum Abmelden wird auf den Pfad \verb|auth/logout| gestellt unter der die Middleware aus Code Ausschnitt \ref{lst:handleLogout} durchlaufen wird. In dieser wird ein abgelaufener \glqq jwt\grqq  -Cookie gesetzt, der bewirkt, dass der bisherige \glqq jwt\grqq -Cookie gelöscht wird. Dann wird dem Frontend mit dem Code 204 geantwortet, welcher aussagt, dass die Anfrage erfolgreich bearbeitet wurde, jedoch keine Daten mit der Antwort gesendet werden\footnote{Quelle \url{https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204} am 05. Mai 2023}.

\subsubsection{Socket.io Authentifizierung und Middleware}
\label{sec:Backend-Socket}
Im Code Ausschnitt \ref{lst:index.js-socket} ist ein Ausschnitt der index.js Datei zu sehen, in der der Socket.io Server initialisiert wird und die Middlewares für socket Verbindungen zugewiesen werden.

\begin{lstlisting}[style=codeStyle, caption={Ausschnitt der index.js Datei mit Socket.io Server Erstellung und Middleware Zuweisung}, label={lst:index.js-socket}]
...
const corsConfig = {
    origin: process.env.FRONTEND_URL,
    credentials: true,
}
const server = require('http').createServer(app);
const io = new Server(server, {
    cors: corsConfig
});
io.use(authorizeUser);
io.use(initializeUser);
io.use((socket, next) => {
    initializeChessListeners(socket, io);
    initializeListeners(socket, io);
    next();
});
...
\end{lstlisting}

Die Initilaisierung des Socket.io Servers benötigt die \verb|corsConfig| Konfiguration, um Verbindungen vom Frontend zuzulassen und Header Informationen wie Cookies mitzusenden.

Es werden drei Middlewares bei einem Verbindungsaufbau durchlaufen,  die ich in diesem Kapitel mit Code ausschnitten erläutern werde.


\begin{lstlisting}[style=codeStyle, caption={authorizeUser Middleware für Socket.io Verbinudngen}, label={lst:authorizeUser}]
/**
 * Middleware that authorizes the socket connection user based on the JWT in the cookie.
 * If the user is successfully authorized, their profile is added to the socket object.
 *
 * @param socket - The socket object representing the connection to the client.
 * @param next - The next middleware function to be called if authorization is successful.
 */
module.exports.authorizeUser = (socket, next) => {
    let token = null;
    if (socket.request.headers.cookie) {
        token = cookie.parse(socket.request.headers.cookie).jwt;
        if (token) {
            jwt.verify(token, process.env.JWT_SECRET, (err, decodedPayload) => {
                if (err) {
                    next(new Error('Unable to Read Token'));
                    return;
                }
                socket.user = {...decodedPayload};
            });
        }
    }
    next();
}
\end{lstlisting}

Die Middleware \verb|authorizeUser| (siehe Code Ausschnitt \ref{lst:authorizeUser} autorisiert den Benutzer. Dabei  wird auf den Cookie zugegriffen, der gegebenenfalls beim Authentifizieren gesetzt wurde, um den Benutzernamen und die \verb|userid| als Attribute der socket zu setzen. Diese Middleware ist der Grund, warum immer eine neue Socket.io Verbindung hergestellt werden muss, sobald der Benutzerzustand und damit der Cookie sich verändert. Ansonsten könnte es sein, dass veraltete Informationen in \verb|socket.user| definiert sind.

\begin{lstlisting}[style=codeStyle, caption={initializeUser Middleware für Socket.io Verbinudngen}, label={lst:initializeUser}]
/**
 * Middleware that initializes the user data when they connect to the socket server.
 * The function retrieves the user's friends, friend requests, and active games data,
 * and sends them to the client. It also emits a 'connected' event to the user's friends.
 *
 * @param socket - The socket object representing the connection to the client.
 * @param next - The next middleware function to be called.
 * @returns {Promise<void>}
 */
module.exports.initializeUser = async (socket, next) => {
    if (socket.user) {
        socket.join(socket.user.userid);
        await setUser(socket.user.username, socket.user.userid, true);
        getFriends(socket.user.username).then(async friends => {
            const parsedFriends = await parseFriendList(friends);
            const friendRooms = parsedFriends.map(friend => friend.userid);
            if (friendRooms.length > 0) {
                socket.to(friendRooms).emit("connected", "true", socket.user.username);
            }
            socket.emit('friends', parsedFriends);
        });
        getFriendRequests(socket.user.username).then(friendRequests => socket.emit('friend_requests', friendRequests));
        getActiveGamesData(socket.user.username).then(gameData => socket.emit('active_games', gameData));
    }
    next();
};
\end{lstlisting}

In der Middleware \verb|initializeUser| werden Daten an den Benutzer gesendet, er wird als online vermerkt und seine Freunde werden darüber informiert, dass er nun online ist. Dies passiert natürlich nur, wenn in der vorherigen Middleware der Benutzer autorisiert werden konnte. Die Funktionen um Daten aus der Redis Datenbank zu lesen oder zu schreiben werden von der Datei \verb|redisController| bereitgestellt.

Zunächst tritt er dem Raum seiner eigenen \verb|userid| bei um Events wie Freundschaftsanfragen, die an ihn gerichtet sind empfangen zu können (siehe Zeile 12). Anschließend wird der Benutzer in Redis gesetzt und als online vermerkt (Zeile 13). Freunde, Freundschaftsanfragen und aktive Spieler werden an den Benutzer mit entsprechenden Events gesendet und alle Freunde werden darüber benachrichtigt, dass der Benutzer online ist.

Die dritte Middleware setzt alle nötigen Listener für Events, die mit dem Schachspiel zusammenhängen, als auch sonstige Funktionen (siehe Code Ausschnitt \ref{lst:index.js-socket}).

\begin{lstlisting}[style=codeStyle, caption={Die onDisconnect Methode für Sockets}, label={lst:onDisconnect}]
/**
 * Function that handles user disconnection from the socket server.
 * The function updates the user's online status and informs all friends,
 * that the user ist offline
 *
 * @param socket - The socket object representing the connection to the client.
 * @returns {Promise<void>}
 */
module.exports.onDisconnect = async (socket) => {
    if (!socket.user) {
        return;
    }
    await setUser(socket.user.username, socket.user.userid, false);
    getFriends(socket.user.username).then(friends => {
        const friendRooms = friends.map(friend => friend.userid);
        if (friendRooms.length > 0) {
            socket.to(friendRooms).emit("connected", "false", socket.user.username);
        }
    });
}
\end{lstlisting}

Die \verb|onDisconnect| Methode aus Code Ausschnitt \ref{lst:onDisconnect} wird aufgerufen, sobald eine socket Verbindung getrennt wird. Ähnlich wie bei der \verb|initializeUser| Middleware (siehe Code Ausschnitt \ref{lst:initializeUser}) wird dabei in Redis der Spieler als offline vermerkt und seine Freunde werden darüber in Kenntnis gesetzt.


\section{Das Schachspiel}
Das Schachspiel verwaltet die Datei \verb|socketChessController.js|, welche eine der Funktionen zur Listener Initialisierung bereitstellt (siehe \verb|initilializeChessListeners| aus Code ausschnitt \ref{lst:index.js-socket}), wobei \verb|ServerChessClock.js| die Schachuhren bereitstellt.

\subsection{Das Spiel}
In diesem Abschnitt werde ich einige Aspekte der Implementierung des Schachspiels mit Code Beispielen erläutern. Funktionen wie Aufgeben, das Ende der Partie oder Chat Nachrichten werden im Abschnitt \ref{sec:Schach-Backend} erläutert und zeichnen sich durch geringere Komplexität aus, weshalb sie in diesem Abschnitt nicht nochmals behandelt werden. Auch das Finden eines Gegners wird in dem Abschnitt der Backend-Architektur detailliert beschrieben, weshalb dies hier nicht noch einmal erläutert wird.

\subsubsection{Initialisierung eines Spiels}
Die Suche und das Finden eines Gegners wurde in Abschnitt \ref{sec:find_game} erläutert. In diesem Abschnitt möchte ich genauer darauf eingehen, wie ein Spiel nach gefundenem Gegner initialisiert wird.

\begin{lstlisting}[style=codeStyle, caption={Die createChessGame Methode zum Initialisieren einer Schachpartie}, label={lst:createChessGame}]
/**
 * Creates a new chess game with two players and initializes the game state and chess clock.
 *
 * @param  io - The Socket.IO server instance.
 * @param  username1 - The username of the first player.
 * @param  username2 - The username of the second player.
 * @param  time - The time mode for the chess clock.
 * @returns {Promise<string>} - Returns a promise that resolves to the new game's room ID.
 */
const createChessGame = async (io, username1, username2, time) => {
    var roomId = UUIDv4();
    const [whitePlayer, blackPlayer] = Math.random() < 0.5 ? [username1, username2] : [username2, username1];

    const chessInstance = await import('../chess/Chess.mjs').then(ChessFile => {
        return ChessFile.Chess();
    });
    const d = new Date();
    chessInstance.header('White', whitePlayer, 'Black', blackPlayer, 'Date', d.toDateString());
    //Store Game in Redis
    await initializeGame(roomId, whitePlayer, blackPlayer, time, chessInstance.pgn());
    const chessClock = new ServerChessClock(time);
    currentChessClocks[roomId] = {chessClock};

    chessClock.startStartingTimer('white');
    chessClock.ChessClockEvents.on('cancel_game', () => {
        io.to(roomId).emit('cancel_game');
        io.to(roomId).emit('stop_clocks');
        endGame(roomId)
    });
    chessClock.ChessClockEvents.on('time_over', (color) => {
        io.to(roomId).emit('time_over', color);
        io.to(roomId).emit('stop_clocks');
        endGame(roomId);
    });
    return roomId;
}
\end{lstlisting}

Die \verb|createChessGame| Methode legt zunächst per Zufall fest, welcher Spieler welche Farbe spielen soll und generiert eine zufällige ID als roomId in der das Spiel stattfindet. Anschließend wird ein chess.js Objekt erstellt. Da es sich bei der Bibliothek chess.js um ein ECMAScript-Module handelt und node.js ein CommonJS-Modulsystem verwendet muss man einen Umweg mittels einer \verb|.mjs|-Datei zum Importieren der Bibliothek verwenden\footnote{Quelle: \url{https://stackoverflow.com/questions/70396400/how-to-use-es6-modules-in-commonjs} am 06. Mai 2023} (siehe Code Ausschnitt \ref{lst:Chess.mjs}).

\begin{lstlisting}[style=codeStyle, caption={Die Chess.mjs Datei}, label={lst:Chess.mjs}]
import {Chess as ChessGame} from 'chess.js';
export const Chess = () => new ChessGame();
\end{lstlisting}

Mit diesem chess.js Objekt generieren wir eine PGN-Notation, in die die Benutzernamen der Spieler und das Datum eingetragen sind. Diese Informationen werden nun in Redis unter \verb|game:roomId| gespeichert, falls die Spieler angemeldet sind auch in deren \verb|activeGames:username| Listen. 

Des weiteren wird ein ServerChessClock Objekt erstellt und in \verb|currentChessClock| mit der roomId als Key gespeichert. Die Kommunikation und der Aufbau von ServerChessClock wird in Abschnitt //REF erläutert.
Eventlistener für die Events der ServerChessClock werden definiert.
Da die Schachuhren und das Schachspiel möglichst Modular gehalten werden, wird an das Frontend in diesen Listenern immer zwei Events gesendet: \verb|time_over| und \verb|cancel_game| für das Schachspiel und \verb|stop_clocks| für die Schachuhren im Frontend. Bei jeder Möglichkeit wie eine Schachpartie endet wird definiert, dass die Funktion \verb|endGame| ausgeführt werden soll, so auch bei diesen zwei Listenern.

\subsubsection{Neue Züge}
\label{sec:new_move_backend}
Beim Eingang eines neuen Zugs mittels des \verb|new_move| Events wird die Methode \verb|newMove| ausgeführt. Sie benötigt die socket des Spielers und die Scoket.io Server Instanz. Die restlichen Daten die sie benötigt werden vom Frontend mit dem Event mitgesendet.

Ein Aktivitätsdiagramm und eine ausführliche Erklärung des Ablaufs wird in Abschnitt \ref{sec:Zug-Backend} behandelt. In diesem Abschnitt konzentrieren wir uns auf die Umsetzung dieser Aktionen im Code.
\begin{lstlisting}[style=codeStyle, caption={newMove Methode die beim Eingang eines neuen Zugs aufgerufen wird}, label={lst:newMove}]
//Listener:
client.on('new_move', newMove(client, io));
/**
 * Handles a new move in a chess game, updates the game state, and communicates
 * the move to the opponent. Also handles game-over scenarios such as checkmate
 * and stalemate.
 *
 * @param socket - The socket of the player making the move.
 * @param io - The socket.io instance.
 * @returns {function(string, Object, Object, function): Promise<void>} - An async function that takes the roomId, player, move, and a callback as arguments.
 */
const newMove = (socket, io) => async (roomId, player, move, cb) => {
    if(!currentChessClocks[roomId]) {
        cb({done: false, errMsg: "Game does not exist"});
        return;
    }
    const {chessClock} = currentChessClocks[roomId];
    const chessInstance = await import('../chess/Chess.mjs').then(ChessFile => {
        return ChessFile.Chess();
    });
    try {
        chessInstance.loadPgn(await getGame(roomId, "pgn").then(pgn => {
            if(!pgn) {
                cb({done: false, errMsg: "Game does not exist"});
                return;
            }
            return pgn;
        }));
        chessInstance.move(move)
    } catch(error) {
        cb({done: false, errMsg: error});
        return;
    }
	
    socket.to(roomId).emit('opponent_move', move);
    //Store move in Redis
    newChessMove(chessInstance.pgn(), roomId).then(r => cb({done: true}));
    
    if(chessInstance.isGameOver()) {
        if (chessInstance.isCheckmate()) {
            io.to(roomId).emit('checkmate', socket.user.username);
        } else {
            io.to(roomId).emit('draw');
        }
        io.to(roomId).emit('stop_clocks');
        chessClock.ChessClockEvents.emit('stop');
        endGame(roomId);
        cb({done: true});
        return;
    }
    
    chessClock.ChessClockEvents.emit('toggle', ({remainingTimeWhite, remainingTimeBlack, turn}) => {
        io.to(roomId).emit('updated_time', remainingTimeWhite, remainingTimeBlack, turn);
    });

    if (chessInstance.history().length === 1) {
        chessClock.startStartingTimer('black');
        io.to(roomId).emit('stop_starting_time_white');
    } else if (chessInstance.history().length === 2) {
        chessClock.startTimer('white');
        io.to(roomId).emit('stop_starting_time_black');
    }
}
\end{lstlisting}

Die Methode holt erst das ServerChessClock Objekt aus dem \verb|currentChessClocks| Array und importiert die aktuelle PGN-Notation des Schachspiels aus der Redis Datenbank in ein chess.js Objekt und macht den Zug darauf.

Die Kommunikation mit dem Frontend erfolgt über verschiedene Events wie \verb|opponent_move|, \verb|chackmate|, \verb|draw|, \verb|stop_clocks|, \verb|updated_time|, \verb|stop_starting_time_white| und \verb|stop_starting_time_black|. Diese Events behandeln entweder ein Ereignis der Schachpartie oder verwalten die Schachuhren. Über die Callback Funktion wird mitgeteilt, ob der Zug erfolgreich behandelt werden konnte oder nicht.

Des weiteren wird die aktualisierte PGN-Notation des Spiels in Redis gespeichert.

\subsubsection{Senden des aktuellen Zustands einer Partie}
Beim Laden der \textit{ChessGame}-Komponente im Frontend wird das Event \verb|get_game_data| gesendet, um den aktuellen Zustand des Spiels zu erhalten und spielen zu können beziehungsweise zugucken zu können. 


\begin{lstlisting}[style=codeStyle, caption={Der Listener des get\_game\_data Events zum übermitteln des Schachspiels}, label={lst:get_game_data}]
client.on('get_game_data', (roomId, guestName, cb) => {
    if (!currentChessClocks.hasOwnProperty(roomId)) {
        cb({done: false, errMsg: "This Game does not exist"});
        return;
    }
    if (!client.rooms.has(roomId)) {
        client.join(roomId);
    }
    if(guestName) {
        client.user = {username: guestName}
    }
    const chessClock = currentChessClocks[roomId].chessClock;
    getGame(roomId)
        .catch(() => {
            console.log('kein Eintrag in redis');
            cb({done: false, errMsg: "This Game does not exist"})
        })
        .then(game => {
                if (!game) {
                    cb({done: false, errMsg: "This Game does not exist"});
                    return;
                }
                game.currentState = chessClock.getCurrentMode();
                if (game.currentState.includes('s')) {
                    game.currentStartingTimer = chessClock.getCurrentStartingTimer();
                } else {
                    game.currentTimes = chessClock.getCurrentTimes();
                }
                cb({done: true, data: game});
            }
        )
});
\end{lstlisting}

Es gibt zwei Szenarien, in denen kein Zustand des Schachspiels gesendet werden kann: Falls kein ServerChessClock Objekt in dem \verb|currentChessClocks| Array vorhanden ist oder falls kein Redis Eintrag zu diesem Spiel gefunden werden konnte.

Essenziell bei diesem Listener ist, dass die socket gegebenenfalls der roomId beitritt, um zukünftige Events, wie neue Züge, erhalten zu können. Außerdem ist es wichtig den Benutzernamen zu setzen, falls es sich um einen Gast handelt. Denn wenn dieser die Seite neu lädt wird eine neue socket Verbindung hergestellt und der Gast-Benutzername wäre nicht mehr in der socket gespeichert. Allerdings wird auf den Benutzernamen der socket z.B. bei einem Schachmatt zugegriffen.

Alle aktuelle Daten, wie welcher Spieler welche farbe spielt und der aktuelle PGN-Notation des Spiels werden aus Redis geholt. Fehlen nur noch die aktuellen Zeiten. Dafür verwenden wie \verb|getCurrentMode()|, um den aktuellen Zustand der Schachuhren zu bekommen (siehe Zeile 23). Diese kann aus folgenden Strings bestehen:

\begin{itemize}
\item \glqq sw\grqq : Gerade läuft die Startzeit von Weiß.
\item \glqq sb\grqq : Die Startzeit von Schwarz läuft
\item \glqq tw\grqq : Die reguläre Zeit von Weiß läuft.
\item \glqq tb\grqq : Die reguläre Zeit von Schwarz läuft.
\end{itemize}

Je nachdem welche Uhren gerade laufen werden entweder die Startzeiten oder die reguären Zeiten der Spieler den Redis Daten hinzugefügt und anschließend dem Frontend per Callback Funktion übermittelt.


\subsection{Die Uhr}
Die Server seitige Schachuhr wird von Objekten der Klasse \verb|ServerChessClock| verwaltet. Diese Objekte besitzen die folgenden Attribute:

\begin{lstlisting}[style=codeStyle, caption={Konstruktor der ServerChessClock Klasse}, label={lst:const-ServerChessClock}]
function ServerChessClock(time) {
    this.timeMode = time;
    this.currentMode = 'off';
    this.remainingTimeWhite = {minutes: time.minutes, seconds: 0};
    this.remainingTimeBlack = {minutes: time.minutes, seconds: 0};
    this.ChessClockEvents = new EventEmitter();
    this.startingTimeWhite = {seconds: 0};
    this.startingTimeBlack = {seconds: 0};
    switch (time.type) {
        case 'Bullet': this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = 15; break;
        case 'Blitz': this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = 20; break;
        case 'Rapid': this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = 30; break;
        case 'Classical': this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = 45; break;
        default: this.startingTimeWhite.seconds = this.startingTimeBlack.seconds = "unknown"; break;
    }
}
\end{lstlisting}

Vorab stelle ich vor, wie ein \verb|time| Objekt aufgebaut ist:
\begin{verbatim}
{type: 'Rapid', minutes: 15, increment: 10, string: '15 + 10'}
\end{verbatim}
\verb|type| Klassifiziert die Schachuhr Konfigurationen zu verschiedenen Modi. Diese Klassifikationen der Schachuhren sind auf online Schach-Plattformen wie \url{lichess.org} bereits Standard. Die Gründe dafür liegen vor allem in der Erweiterbarkeit (siehe //REF). Bisher werden sie genutzt um wie in Zeilen 9 ff. des Code Ausschnitts \ref{lst:const-ServerChessClock} verschiedene Startzeiten zu initialisieren.

\verb|string| dient der Darstellung und der einfachen Identifizierung dieser Objekte.


\begin{lstlisting}[style=codeStyle, caption={Die startTimer und stopCurrentGame Methoden der ServerChessClock Klasse}, label={lst:startTimer}]
/**
 * Starts the timer for the given player color and manages time increments and game over events.
 *
 * @param {string} color - The color of the player for whom the timer should start ("white" or "black").
 */
ServerChessClock.prototype.startTimer = function (color) {
    let currentPlayerTime;
    if (color === "white") {
        currentPlayerTime = this.remainingTimeWhite;
        this.currentMode = "tw";
    } else {
        currentPlayerTime = this.remainingTimeBlack;
        this.currentMode = "tb";
    }

    const isTimeOver = () => {
        return currentPlayerTime.minutes === 0 && currentPlayerTime.seconds === 0;
    };

    const decreaseTime = () => {
        if (currentPlayerTime.seconds === 0) {
            currentPlayerTime.minutes -= 1;
            currentPlayerTime.seconds = 59;
        } else {
            currentPlayerTime.seconds -= 1;
        }
    };

    const timer = setInterval(() => {
        decreaseTime();
        if (isTimeOver()) {
            clearInterval(timer);
            this.stopCurrentGame();

        }
    }, 1000);
    
	//If game ends, because player resigned, checkmate, ...
    this.ChessClockEvents.once("stop", () => {
        clearInterval(timer);
    });
    
    //If a player played a new move
    this.ChessClockEvents.once("toggle", (cb) => {
        clearInterval(timer);
        if (color === "white") {
            this.remainingTimeWhite = increment(
                currentPlayerTime,
                this.timeMode.increment
            );
            cb({
                remainingTimeWhite: this.remainingTimeWhite,
                remainingTimeBlack: this.remainingTimeBlack,
                turn: "tb",
            });
            this.startTimer("black");
        } else {
            this.remainingTimeBlack = increment(
                currentPlayerTime,
                this.timeMode.increment
            );
            cb({
                remainingTimeWhite: this.remainingTimeWhite,
                remainingTimeBlack: this.remainingTimeBlack,
                turn: "tw",
            });
            this.startTimer("white");
        }
    });
};

/**
 * Called if a time is run out
 */
ServerChessClock.prototype.stopCurrentGame = function () {
    if (this.getCurrentMode().includes('s')) {
        this.ChessClockEvents.emit('cancel_game');
    } else if (this.getCurrentMode().includes('w')) {
        this.ChessClockEvents.emit('time_over', 'white');
    } else {
        this.ChessClockEvents.emit('time_over', 'black');
    }
}
\end{lstlisting}

Die Funktion \verb|startTimer| wird ein mal von \verb|SocketChessController| aufgerufen, falls der zweite Zug gespielt wurde (siehe Code Ausschnitt \ref{lst:newMove}). Anschließend wird die Methode selbst rekursiv aufgerufen, falls ein neuer Zug gespielt wurde (siehe Zeile 56 \& 67 im Code Ausschnitt \ref{lst:startTimer}).

Je nachdem welche Zeit läuft, wird \verb|currentMode| aktualisiert und die entsprechende Zeit wird als \verb|currentPlayerTime| definiert.

Die Zeit läuft korrekt ab, durch den \verb|timer|, welcher \verb|setInterval| nutzt, um jede Sekunde mittels \verb|decreaseTime| die Zeit ablaufen zu lassen und \verb|isTimeOver| um zu überprüfen ob die Zeit abgelaufen ist.

Es wird ein Listener definiert, welcher bei einem neuen Zug das Inkrement auf die entsprechende Zeit rechnet und mittels Callback Funktion die aktuellen Zeiten durchgibt, um diese in der \verb|newMove| Methode an das Frontend zu senden (siehe \ref{sec:new_move_backend}). Dieser Listener wird mit \verb|ones(...)| definiert, wodurch er nur ein mal auf das Event hört. Dies ist wichtig, da anschließend die \verb|startTimer| Methode reukursiv aufgerufen wird und der Listnerer neu initialisiert wird.

Die \verb|stopCurrentGame| Methode wird aufgerufen, falls eine Zeit (Startzeit oder reguläre Zeit) abgelaufen ist und sendet entsprechende Events an SocketChessController.
